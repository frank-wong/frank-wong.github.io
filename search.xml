<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 常用命令</title>
    <url>/frank-wong.github.io/posts/f1efb8a3/</url>
    <content><![CDATA[<p>docker常用命令参考</p>
<a id="more"></a>
<h1 id="一-docker常用命令"><a href="#一-docker常用命令" class="headerlink" title="一. docker常用命令"></a>一. docker常用命令</h1><h2 id="1-1-Docker环境信息"><a href="#1-1-Docker环境信息" class="headerlink" title="1.1 Docker环境信息"></a>1.1 Docker环境信息</h2><p>用于检测Docker是否正确安装，一般结合docker version命令使用</p>
<h3 id="1-1-1-docker-info"><a href="#1-1-1-docker-info" class="headerlink" title="1.1.1 docker info"></a>1.1.1 docker info</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker info : 显示 Docker 系统信息，包括镜像和容器数。。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker info [OPTIONS]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看docker系统信息</span><br><span class="line"></span><br><span class="line">[root@frankwong yunwei]<span class="comment"># docker info</span></span><br><span class="line">Client:</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 0</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 1</span><br><span class="line"> Images: 2</span><br><span class="line"> Server Version: 18.09.1</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: xfs</span><br><span class="line">  Supports d_type: <span class="literal">true</span></span><br><span class="line">  Native Overlay Diff: <span class="literal">true</span></span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: <span class="built_in">local</span></span><br><span class="line">  Network: bridge host macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file <span class="built_in">local</span> logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: c4446665cb9c30056f4998ed953e6d4ff22c7c39</span><br><span class="line"> runc version: 4fc53a81fb7c994640722ac585fa9ca548971871</span><br><span class="line"> init version: fec3683</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 4.18.0-147.el8.x86_64</span><br><span class="line"> Operating System: CentOS Linux 8 (Core)</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 2</span><br><span class="line"> Total Memory: 1.919GiB</span><br><span class="line"> Name: frankwong</span><br><span class="line"> ID: ZMS7:D2RT:4JJT:7IB2:AMN2:WPDO:NU5V:VZ5H:DIPN:57ZW:D4US:JAG4</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"> Product License: Community Engine</span><br><span class="line"></span><br><span class="line">[root@frankwong yunwei]<span class="comment">#</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-2-docker-version"><a href="#1-1-2-docker-version" class="headerlink" title="1.1.2 docker version"></a>1.1.2 docker version</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker version :显示 Docker 版本信息</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker version [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :指定返回值的模板文件</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">显示 Docker 版本信息</span><br><span class="line"></span><br><span class="line">[root@frankwong yunwei]<span class="comment"># docker version</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.11</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.13.10</span><br><span class="line"> Git commit:        42e35e61f3</span><br><span class="line"> Built:             Mon Jun  1 09:13:48 2020</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.1</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       4c52b90</span><br><span class="line">  Built:            Wed Jan  9 19:06:30 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line">[root@frankwong yunwei]<span class="comment">#</span></span><br></pre></td></tr></table></figure></div>


<h2 id="1-2-容器生命周期管理"><a href="#1-2-容器生命周期管理" class="headerlink" title="1.2 容器生命周期管理"></a>1.2 容器生命周期管理</h2><h3 id="1-2-1-docker-create"><a href="#1-2-1-docker-create" class="headerlink" title="1.2.1 docker create"></a>1.2.1 docker create</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker create ：创建一个新的容器但不启动它</span><br><span class="line">用法同 docker run</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">语法同 docker run</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      </span><br><span class="line">09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-2-docker-exec"><a href="#1-2-2-docker-exec" class="headerlink" title="1.2.2 docker exec"></a>1.2.2 docker exec</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> ：在运行的容器中执行命令</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line">-t :分配一个伪终端</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</span><br><span class="line"></span><br><span class="line">  runoob@runoob:~$ docker <span class="built_in">exec</span> -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">  http://www.runoob.com/</span><br><span class="line"></span><br><span class="line">在容器 mynginx 中开启一个交互模式的终端:</span><br><span class="line"></span><br><span class="line">  runoob@runoob:~$ docker <span class="built_in">exec</span> -i -t  mynginx /bin/bash</span><br><span class="line">  root@b1a0703e41e7:/<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</span><br><span class="line">查看已经在运行的容器 ID：</span><br><span class="line"></span><br><span class="line">  <span class="comment"># docker ps -a </span></span><br><span class="line">  ...</span><br><span class="line">  9df70f9a0714        openjdk             <span class="string">"/usercode/script.sh…"</span> </span><br><span class="line">  ...</span><br><span class="line">第一列的 9df70f9a0714 就是容器 ID。</span><br><span class="line"></span><br><span class="line">通过 <span class="built_in">exec</span> 命令对指定的容器执行 bash:</span><br><span class="line">  <span class="comment"># docker exec -it 9df70f9a0714 /bin/bash</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-3-docker-run"><a href="#1-2-3-docker-run" class="headerlink" title="1.2.3 docker run"></a>1.2.3 docker run</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker run ：创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">-a stdin</span><br><span class="line">指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">-d</span><br><span class="line">后台运行容器，并返回容器ID；</span><br><span class="line">-i</span><br><span class="line">以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-P</span><br><span class="line">随机端口映射，容器内部端口随机映射到主机的高端口</span><br><span class="line">-p</span><br><span class="line">指定端口映射，格式为：主机(宿主)端口:容器端口</span><br><span class="line">-t</span><br><span class="line">为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name=<span class="string">"nginx-lb"</span></span><br><span class="line">为容器指定一个名称；</span><br><span class="line">--dns 8.8.8.8</span><br><span class="line">指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line">--dns-search example.com</span><br><span class="line">指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line">-h <span class="string">"mars"</span></span><br><span class="line">指定容器的hostname；</span><br><span class="line">-e username=<span class="string">"ritchie"</span></span><br><span class="line">设置环境变量；</span><br><span class="line">--env-file=[]</span><br><span class="line">从指定文件读入环境变量；</span><br><span class="line">--cpuset=<span class="string">"0-2"</span> or --cpuset=<span class="string">"0,1,2"</span></span><br><span class="line">绑定容器到指定CPU运行；</span><br><span class="line">-m</span><br><span class="line">设置容器使用内存最大值；</span><br><span class="line">--net=<span class="string">"bridge"</span></span><br><span class="line">指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">--link=[]</span><br><span class="line">添加链接到另一个容器；</span><br><span class="line">--expose=[]</span><br><span class="line">开放一个端口或一组端口；</span><br><span class="line">--volume , -v</span><br><span class="line">绑定一个卷</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span><br><span class="line"></span><br><span class="line">  docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</span><br><span class="line"></span><br><span class="line">  docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span><br><span class="line"></span><br><span class="line">  docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span><br><span class="line"></span><br><span class="line">  $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></div>



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">从image启动一个container（run）</span><br><span class="line">docker run命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多。</span><br><span class="line"></span><br><span class="line">当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</span><br><span class="line"></span><br><span class="line">检查本地是否存在指定的镜像，不存在就从公有仓库下载</span><br><span class="line">利用镜像创建并启动一个容器</span><br><span class="line">分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</span><br><span class="line">从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</span><br><span class="line">从地址池配置一个 ip 地址给容器</span><br><span class="line">执行用户指定的应用程序</span><br><span class="line">执行完毕后容器被终止</span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用image创建container并执行相应命令，然后停止</span><br><span class="line"><span class="comment"># docker run ubuntu echo "hello world"</span></span><br><span class="line">hello word</span><br><span class="line">这是最简单的方式，跟在本地直接执行<span class="built_in">echo</span> <span class="string">'hello world'</span> 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（docker ps -l可查看）。需要注意的是，默认有一个--rm=<span class="literal">true</span>参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</span><br><span class="line">容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID</span><br><span class="line"></span><br><span class="line">使用image创建container并进入交互模式, login shell是/bin/bash</span><br><span class="line"><span class="comment"># docker run -i -t --name mytest centos:centos6 /bin/bash</span></span><br><span class="line">bash-4.1<span class="comment">#</span></span><br><span class="line">上面的--name参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像centos:centos6也可以用IMAGE ID (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。此时使用<span class="built_in">exit</span>或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）</span><br><span class="line">（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行出一个container放到后台运行</span><br><span class="line"><span class="comment"># docker run -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 2; done"</span></span><br><span class="line">ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc</span><br><span class="line">它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个CONTAINER ID，通过docker ps可以看到这个容器的信息，可在container外面查看它的输出docker logs ae60c4b64205，也可以通过docker attach ae60c4b64205连接到这个正在运行的终端，此时在Ctrl+C退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行</span><br><span class="line">另外，如果-d启动但后面的命令执行完就结束了，如/bin/bash、<span class="built_in">echo</span> <span class="built_in">test</span>，则container做完该做的时候依然会终止。而且-d不能与--rm同时使用</span><br><span class="line">可以通过这种方式来运行memcached、apache等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">映射host到container的端口和目录</span><br><span class="line">映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如-p &lt;host_port:contain_port&gt;，存在以下几种写法：</span><br><span class="line"></span><br><span class="line">-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上</span><br><span class="line">-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口</span><br><span class="line">-p 127.0.0.1::5000</span><br><span class="line">-p 127.0.0.1:80:8080</span><br><span class="line">目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，-v &lt;host_path:container_path&gt;，绑定多个目录时再加-v。</span><br><span class="line"></span><br><span class="line">-v /tmp/docker:/tmp/docker</span><br><span class="line">另外在两个container之间建立联系可用--link，详见高级部分或官方文档。</span><br><span class="line">下面是一个例子：</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run --name nginx_test \</span></span><br><span class="line">&gt; -v /tmp/docker:/usr/share/nginx/html:ro \</span><br><span class="line">&gt; -p 80:80 -d \</span><br><span class="line">&gt; nginx:1.7.6</span><br><span class="line">在主机的/tmp/docker下建立index.html，就可以通过http://localhost:80/或http://host-ip:80访问了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将一个container固化为一个新的image（commit）</span><br><span class="line">当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。</span><br><span class="line">docker commit &lt;container&gt; [repo:tag]</span><br><span class="line">后面的repo:tag可选</span><br><span class="line">只能提交正在运行的container，即通过docker ps可以看见的容器，</span><br><span class="line"></span><br><span class="line">查看刚运行过的容器</span><br><span class="line"><span class="comment"># docker ps -l</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMES</span><br><span class="line">c9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test</span><br><span class="line"></span><br><span class="line">启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  </span><br><span class="line">[root@hostname docker]<span class="comment"># docker start c9fdf26326c9</span></span><br><span class="line">c9fdf26326c9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -i -t --sig-proxy=<span class="literal">false</span> 21ffe545748baf /bin/bash</span><br><span class="line">nginx服务没有启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker commit -m "some tools installed" fcbd0a5348ca seanlook/ubuntu:14.10_tutorial</span></span><br><span class="line">fe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503</span><br><span class="line">-a <span class="string">"seanlook7@gmail.com"</span></span><br><span class="line">请注意，当你反复去commit一个容器的时候，每次都会得到一个新的IMAGE ID，假如后面的repository:tag没有变，通过docker images可以看到，之前提交的那份镜像的repository:tag就会变成&lt;none&gt;:&lt;none&gt;，所以尽量避免反复提交。</span><br><span class="line">另外，观察以下几点:</span><br><span class="line"></span><br><span class="line">commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：</span><br><span class="line"></span><br><span class="line">你可以重新提交得到新image2，删除次新的image1</span><br><span class="line">也可以关闭容器用新image1启动，继续修改，提交image2后删除image1</span><br><span class="line">当然这样会很痛苦，所以一般是采用Dockerfile来build得到最终image，参考[]</span><br><span class="line">虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。</span><br><span class="line">下</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-4-docker-start、stop、restart"><a href="#1-2-4-docker-start、stop、restart" class="headerlink" title="1.2.4 docker start、stop、restart"></a>1.2.4 docker start、stop、restart</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">开启/停止/重启container（start/stop/restart）</span><br><span class="line">容器可以通过run新建一个来运行，也可以重新start已经停止的container，但start不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。</span><br><span class="line">容器stop（或Ctrl+D）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入attach进去的界面是一样的，与第一次run启动或commit提交的时刻相同。</span><br><span class="line"></span><br><span class="line">CONTAINER_ID=$(docker start &lt;containner_id&gt;)</span><br><span class="line">docker stop <span class="variable">$CONTAINER_ID</span></span><br><span class="line">docker restart <span class="variable">$CONTAINER_ID</span></span><br><span class="line">关于这几个命令可以通过一个完整的实例使用：docker如何创建一个运行后台进程的容器并同时提供shell终端。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker start :启动一个或多个已经被停止的容器</span><br><span class="line">docker stop :停止一个运行中的容器</span><br><span class="line">docker restart :重启容器</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">重启容器myrunoob</span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-5-docker-kill"><a href="#1-2-5-docker-kill" class="headerlink" title="1.2.5 docker kill"></a>1.2.5 docker kill</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> :杀掉一个运行中的容器。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-s :向容器发送一个信号</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">杀掉运行中的容器mynginx</span><br><span class="line">runoob@runoob:~$ docker <span class="built_in">kill</span> -s KILL mynginx</span><br><span class="line">mynginx</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-6-docker-rm"><a href="#1-2-6-docker-rm" class="headerlink" title="1.2.6 docker rm"></a>1.2.6 docker rm</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker rm ：删除一个或多个容器。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :通过 SIGKILL 信号强制删除一个运行中的容器。</span><br><span class="line">-l :移除容器间的网络连接，而非容器本身。</span><br><span class="line">-v :删除与容器关联的卷。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">强制删除容器 db01、db02：</span><br><span class="line"></span><br><span class="line">  docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">移除容器 nginx01 对容器 db01 的连接，连接名 db：</span><br><span class="line"></span><br><span class="line">  docker rm -l db </span><br><span class="line"></span><br><span class="line">删除容器 nginx01, 并删除容器挂载的数据卷：</span><br><span class="line"></span><br><span class="line">  docker rm -v nginx01</span><br><span class="line"></span><br><span class="line">删除所有已经停止的容器：</span><br><span class="line"></span><br><span class="line">  docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-7-docker-pause、unpause"><a href="#1-2-7-docker-pause、unpause" class="headerlink" title="1.2.7 docker pause、unpause"></a>1.2.7 docker pause、unpause</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker pause :暂停容器中所有的进程。</span><br><span class="line">docker unpause :恢复容器中所有的进程。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">暂停数据库容器db01提供服务。</span><br><span class="line"></span><br><span class="line">  docker pause db01</span><br><span class="line"></span><br><span class="line">恢复数据库容器db01提供服务。</span><br><span class="line"></span><br><span class="line">  docker unpause db01</span><br></pre></td></tr></table></figure></div>


<h2 id="1-3-容器操作运维"><a href="#1-3-容器操作运维" class="headerlink" title="1.3 容器操作运维"></a>1.3 容器操作运维</h2><h3 id="1-3-1-docker-ps"><a href="#1-3-1-docker-ps" class="headerlink" title="1.3.1 docker ps"></a>1.3.1 docker ps</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">查看容器的信息container（ps）</span><br><span class="line"></span><br><span class="line">docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。</span><br><span class="line">最常用的功能是通过ps来找到CONTAINER_ID，以便对特定容器进行操作。</span><br><span class="line"></span><br><span class="line">docker ps    默认显示当前正在运行中的container</span><br><span class="line"></span><br><span class="line">docker ps -a 查看包括已经停止的所有容器</span><br><span class="line"></span><br><span class="line">docker ps -l 显示最新启动的一个容器（包括已停止的）</span><br><span class="line"></span><br><span class="line">查看容器的信息container（ps）</span><br><span class="line">docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。经常通过ps来找到CONTAINER_ID。</span><br><span class="line">docker ps 默认显示当前正在运行中的container</span><br><span class="line">docker ps -a 查看包括已经停止的所有容器</span><br><span class="line">docker ps -l 显示最新启动的一个容器（包括已停止的）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker ps : 列出容器</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :显示所有的容器，包括未运行的。</span><br><span class="line">-f :根据条件过滤显示的内容。</span><br><span class="line">--format :指定返回值的模板文件。</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n :列出最近创建的n个容器。</span><br><span class="line">--no-trunc :不截断输出。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">列出所有在运行的容器信息。</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   <span class="string">"nginx -g 'daemon off"</span> ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line">96f7f14e99ab   mysql:5.6      <span class="string">"docker-entrypoint.sh"</span> ...  0.0.0.0:3306-&gt;3306/tcp   mymysql</span><br><span class="line"></span><br><span class="line">输出详情介绍：</span><br><span class="line">  CONTAINER ID: 容器 ID。</span><br><span class="line">  IMAGE: 使用的镜像。</span><br><span class="line">  COMMAND: 启动容器时运行的命令。</span><br><span class="line">  CREATED: 容器的创建时间。</span><br><span class="line">  STATUS: 容器状态</span><br><span class="line"></span><br><span class="line">状态有7种：</span><br><span class="line">  created（已创建）</span><br><span class="line">  restarting（重启中）</span><br><span class="line">  running（运行中）</span><br><span class="line">  removing（迁移中）</span><br><span class="line">  paused（暂停）</span><br><span class="line">  exited（停止）</span><br><span class="line">  dead（死亡）</span><br><span class="line"></span><br><span class="line">PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</span><br><span class="line">NAMES: 自动分配的容器名称。</span><br><span class="line"></span><br><span class="line">列出最近创建的5个容器信息</span><br><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        <span class="string">"nginx -g 'daemon off"</span>    2 days ago   ...     </span><br><span class="line">b8573233d675        nginx:latest        <span class="string">"/bin/bash"</span>               2 days ago   ...     </span><br><span class="line">b1a0703e41e7        nginx:latest        <span class="string">"nginx -g 'daemon off"</span>    2 days ago   ...    </span><br><span class="line">f46fb1dec520        5c6e1090e771        <span class="string">"/bin/sh -c 'set -x \t"</span>   2 days ago   ...   </span><br><span class="line">a63b4a5597de        860c279d2fec        <span class="string">"bash"</span>                    2 days ago   ...</span><br><span class="line"></span><br><span class="line">列出所有创建的容器ID</span><br><span class="line">runoob@runoob:~$ docker ps -a -q</span><br><span class="line">09b93464c2f7</span><br><span class="line">b8573233d675</span><br><span class="line">b1a0703e41e7</span><br><span class="line">f46fb1dec520</span><br><span class="line">a63b4a5597de</span><br><span class="line">6a4aa42e947b</span><br><span class="line">de7bb36e7968</span><br><span class="line">43a432b73776</span><br><span class="line">664a8ab1a585</span><br><span class="line">ba52eb632bbd</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">根据条件过滤显示的内容</span><br><span class="line">根据标签过滤</span><br><span class="line">$ docker run -d --name=<span class="built_in">test</span>-nginx --label color=blue nginx</span><br><span class="line">$ docker ps --filter <span class="string">"label=color"</span></span><br><span class="line">$ docker ps --filter <span class="string">"label=color=blue"</span></span><br><span class="line"></span><br><span class="line">根据名称过滤</span><br><span class="line">$ docker ps --filter<span class="string">"name=test-nginx"</span></span><br><span class="line"></span><br><span class="line">根据状态过滤</span><br><span class="line">$ docker ps -a --filter <span class="string">'exited=0'</span></span><br><span class="line">$ docker ps --filter status=running</span><br><span class="line">$ docker ps --filter status=paused</span><br><span class="line"></span><br><span class="line">根据镜像过滤</span><br><span class="line"><span class="comment">#镜像名称</span></span><br><span class="line">$ docker ps --filter ancestor=nginx</span><br><span class="line"><span class="comment">#镜像ID</span></span><br><span class="line">$ docker ps --filter ancestor=d0e008c6cf02</span><br><span class="line"></span><br><span class="line">根据启动顺序过滤</span><br><span class="line">$ docker ps -f before=9c3527ed70ce</span><br><span class="line">$ docker ps -f since=6e63f6ff38b0</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-2-docker-inspect"><a href="#1-3-2-docker-inspect" class="headerlink" title="1.3.2 docker inspect"></a>1.3.2 docker inspect</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">--inspect命令</span><br><span class="line">用于查看镜像和容器的详细信息，默认会列出全部信息，可以通过--format参数来指定输出的模板格式，以便输出特定信息。</span><br><span class="line"></span><br><span class="line">查看image或container的底层信息（inspect）</span><br><span class="line">inspect的对象可以是image、运行中的container和停止的container。</span><br><span class="line"></span><br><span class="line">查看容器的内部IP</span><br><span class="line"><span class="comment"># docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' $CONTAINER_ID</span></span><br><span class="line">172.17.42.35</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker inspect : 获取容器/镜像的元数据</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :指定返回值的模板文件</span><br><span class="line">-s :显示总的文件大小</span><br><span class="line">--<span class="built_in">type</span> :为指定类型返回JSON</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">获取镜像mysql:5.6的元信息</span><br><span class="line">runoob@runoob:~$ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"mysql:5.6"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [],</span><br><span class="line">        <span class="string">"Parent"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Comment"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2016-05-24T04:01:41.168371815Z"</span>,</span><br><span class="line">        <span class="string">"Container"</span>: <span class="string">"e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54"</span>,</span><br><span class="line">        <span class="string">"ContainerConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"b0cf605c7757"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"ExposedPorts"</span>: &#123;</span><br><span class="line">                <span class="string">"3306/tcp"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">获取正在运行的容器mymysql的 IP</span><br><span class="line">runoob@runoob:~$ docker inspect --format=<span class="string">'&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-3-docker-top"><a href="#1-3-3-docker-top" class="headerlink" title="1.3.3 docker top"></a>1.3.3 docker top</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">查看容器中正在运行的进程（top）</span><br><span class="line">容器运行时不一定有/bin/bash终端来交互执行top命令，查看container中正在运行的进程，况且还不一定有top命令，这是docker top &lt;container_id/container_name&gt;就很有用了。实际上在host上使用ps -ef|grep docker也可以看到一组类似的进程信息，把container里的进程看成是host上启动docker的子进程就对了。</span><br><span class="line"></span><br><span class="line">docker top :查看容器中运行的进程信息，支持 ps 命令参数</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br><span class="line"></span><br><span class="line">容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看容器mymysql的进程信息</span><br><span class="line">runoob@runoob:~/mysql$ docker top mymysql</span><br><span class="line">UID    PID    PPID    C      STIME   TTY  TIME       CMD</span><br><span class="line">999    40347  40331   18     00:58   ?    00:00:02   mysqld</span><br><span class="line"></span><br><span class="line">查看所有运行容器的进程信息</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  `docker ps |grep Up|awk <span class="string">'&#123;print $1&#125;'</span>`;<span class="keyword">do</span> <span class="built_in">echo</span> \ &amp;&amp;docker top <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-4-docker-attach"><a href="#1-3-4-docker-attach" class="headerlink" title="1.3.4 docker attach"></a>1.3.4 docker attach</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">--attach命令</span><br><span class="line">docker attach命令对应开发者很有用，可以连接到正在运行的容器，观察容器的运行状况，或与容器的主进程进行交互。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">连接到正在运行中的container（attach）</span><br><span class="line">要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</span><br><span class="line">官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=<span class="literal">false</span>来确保CTRL-D或CTRL-C不会关闭容器。</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker attach --sig-proxy=false $CONTAINER_ID</span></span><br><span class="line"></span><br><span class="line">docker attach :连接到正在运行中的容器</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker attach [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</span><br><span class="line"></span><br><span class="line">官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=<span class="literal">false</span>来确保CTRL-D或CTRL-C不会关闭容器。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">runoob@runoob:~$ docker attach --sig-proxy=<span class="literal">false</span> mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] <span class="string">"GET / HTTP/1.1"</span> 304 0 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-5-docker-wait"><a href="#1-3-5-docker-wait" class="headerlink" title="1.3.5 docker wait"></a>1.3.5 docker wait</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">wait</span> : 阻塞运行直到容器停止，然后打印出它的退出代码</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker <span class="built_in">wait</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">docker <span class="built_in">wait</span> &lt;CONTAINER&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-6-docker-export"><a href="#1-3-6-docker-export" class="headerlink" title="1.3.6 docker export"></a>1.3.6 docker export</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> :将文件系统作为一个tar归档文件导出到STDOUT</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker <span class="built_in">export</span> [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-o :将输入内容写到文件</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将id为a404c6c174a2的容器按日期保存为tar文件</span><br><span class="line">runoob@runoob:~$ docker <span class="built_in">export</span> -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-7-docker-port"><a href="#1-3-7-docker-port" class="headerlink" title="1.3.7 docker port"></a>1.3.7 docker port</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看容器mynginx的端口映射情况</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-8-docker-rename"><a href="#1-3-8-docker-rename" class="headerlink" title="1.3.8 docker rename"></a>1.3.8 docker rename</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-9-docker-stat"><a href="#1-3-9-docker-stat" class="headerlink" title="1.3.9 docker stat"></a>1.3.9 docker stat</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="1-4-容器rootfs名"><a href="#1-4-容器rootfs名" class="headerlink" title="1.4 容器rootfs名"></a>1.4 容器rootfs名</h2><h3 id="1-4-1-docker-commit"><a href="#1-4-1-docker-commit" class="headerlink" title="1.4.1 docker commit"></a>1.4.1 docker commit</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker commit :从容器创建一个新的镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息</span><br><span class="line">runoob@runoob:~$ docker commit -a <span class="string">"runoob.com"</span> -m <span class="string">"my apache"</span> a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="1-4-2-docker-cp"><a href="#1-4-2-docker-cp" class="headerlink" title="1.4.2 docker cp"></a>1.4.2 docker cp</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker cp :用于容器与主机之间的数据拷贝</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-L :保持源目标中的链接</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line"></span><br><span class="line">将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line"></span><br><span class="line">将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure></div>

<h3 id="1-4-3-docker-diff"><a href="#1-4-3-docker-diff" class="headerlink" title="1.4.3 docker diff"></a>1.4.3 docker diff</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker diff : 检查容器里文件结构的更改</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker diff [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看容器mymysql的文件结构更改</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure></div>



<h2 id="1-5-镜像仓库"><a href="#1-5-镜像仓库" class="headerlink" title="1.5 镜像仓库"></a>1.5 镜像仓库</h2><h3 id="1-5-1-docker-login、logout"><a href="#1-5-1-docker-login、logout" class="headerlink" title="1.5.1 docker login、logout"></a>1.5.1 docker login、logout</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span><br><span class="line">docker <span class="built_in">logout</span> : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker <span class="built_in">logout</span> [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-u :登陆的用户名</span><br><span class="line">-p :登陆的密码</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line">登出Docker Hub</span><br><span class="line">docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-5-2-docker-pull"><a href="#1-5-2-docker-pull" class="headerlink" title="1.5.2 docker pull"></a>1.5.2 docker pull</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">从docker registry server 中下拉image或repository（pull）</span><br><span class="line"></span><br><span class="line">Usage: docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker pull centos</span></span><br><span class="line">上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。</span><br><span class="line">也可以明确指定具体的镜像：</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker pull centos:centos6</span></span><br><span class="line">当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如docker pull username/repository&lt;:tag_name&gt; ：</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker pull seanlook/centos:centos6</span></span><br><span class="line">如果你没有网络，或者从其他私服获取镜像，形如docker pull registry.domain.com:5000/repos:&lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker pull dl.dockerpool.com:5000/mongo:latest</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull : 从镜像仓库中拉取或者更新指定镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :拉取所有 tagged 镜像</span><br><span class="line">--<span class="built_in">disable</span>-content-trust :忽略镜像的校验,默认开启</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">从Docker Hub下载java最新版镜像</span><br><span class="line">docker pull java</span><br><span class="line"></span><br><span class="line">从Docker Hub下载REPOSITORY为java的所有镜像</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5-3-docker-push"><a href="#1-5-3-docker-push" class="headerlink" title="1.5.3 docker push"></a>1.5.3 docker push</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">推送一个image或repository到registry（push）</span><br><span class="line">与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker push seanlook/mongo</span></span><br><span class="line"><span class="comment"># docker push registry.tp-link.net:5000/mongo:2014-10-27</span></span><br><span class="line">registry.tp-link.net也可以写成IP，172.29.88.222。</span><br><span class="line">在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">--<span class="built_in">disable</span>-content-trust :忽略镜像的校验,默认开启</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">上传本地镜像myapache:v1到镜像仓库中</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5-4-docker-search"><a href="#1-5-4-docker-search" class="headerlink" title="1.5.4 docker search"></a>1.5.4 docker search</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">在docker index中搜索image（search）</span><br><span class="line"></span><br><span class="line">Usage: docker search TERM</span><br><span class="line"></span><br><span class="line">[root@frankwong yunwei]<span class="comment"># docker search node</span></span><br><span class="line">NAME                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                   Node.js is a JavaScript-based platform <span class="keyword">for</span> s…   8900                [OK]                </span><br><span class="line">mongo-express                          Web-based MongoDB admin interface, written w…   707                 [OK]                </span><br><span class="line">nodered/node-red-docker                Deprecated - older Node-RED Docker images.      345                                     [OK]</span><br><span class="line">selenium/node-chrome                                                                   209                                     [OK]</span><br><span class="line">prom/node-exporter                                                                     188                                     [OK]</span><br><span class="line">nodered/node-red                       Low-code programming <span class="keyword">for</span> event-driven applic…   139                                     </span><br><span class="line">selenium/node-firefox                                                                  133                                     [OK]</span><br><span class="line">circleci/node                          Node.js is a JavaScript-based platform <span class="keyword">for</span> s…   106                                     </span><br><span class="line">digitallyseamless/nodejs-bower-grunt    Node.js w/ Bower &amp; Grunt Dockerfile <span class="keyword">for</span> tru…   48                                      [OK]</span><br><span class="line">kkarczmarczyk/node-yarn                Node docker image with yarn package manager …   48                                      [OK]</span><br><span class="line">bitnami/node                           Bitnami Node.js Docker Image                    44                                      [OK]</span><br><span class="line">iron/node                              Tiny Node image                                 29                                      </span><br><span class="line">calico/node                            Calico<span class="string">'s per-host DaemonSet container image.…   19                                      [OK]</span></span><br><span class="line"><span class="string">appsvc/node                            Azure App Service Node.js dockerfiles           14                                      [OK]</span></span><br><span class="line"><span class="string">centos/nodejs-8-centos7                Platform for building and running Node.js 8 …   11                                      </span></span><br><span class="line"><span class="string">basi/node-exporter                     Node exporter image that allows to expose th…   8                                       [OK]</span></span><br><span class="line"><span class="string">cusspvz/node                            Super small Node.js container (~15MB) bas…    7                                       [OK]</span></span><br><span class="line"><span class="string">tarampampam/node                       Docker image, based on node, with some addit…   3                                       [OK]</span></span><br><span class="line"><span class="string">ogazitt/node-env                       node app that shows environment variables       2                                       </span></span><br><span class="line"><span class="string">ppc64le/node                           Node.js is a JavaScript-based platform for s…   2                                       </span></span><br><span class="line"><span class="string">nodecg/nodecg                          Create broadcast graphics using Node.js and …   1                                       [OK]</span></span><br><span class="line"><span class="string">bitnami/node-exporter                  Bitnami Node Exporter Docker Image              1                                       [OK]</span></span><br><span class="line"><span class="string">testim/node-chrome                     Selenium Chrome Node + Testim Extension         0                                       [OK]</span></span><br><span class="line"><span class="string">camptocamp/node-collectd               rancher node monitoring agent                   0                                       [OK]</span></span><br><span class="line"><span class="string">appsvctest/node                        node build                                      0                                       [OK]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker search : 从Docker Hub查找镜像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语法</span></span><br><span class="line"><span class="string">docker search [OPTIONS] TERM</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OPTIONS说明：</span></span><br><span class="line"><span class="string">--automated :只列出 automated build类型的镜像；</span></span><br><span class="line"><span class="string">--no-trunc :显示完整的镜像描述；</span></span><br><span class="line"><span class="string">-s :列出收藏数不小于指定值的镜像。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实例</span></span><br><span class="line"><span class="string">从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</span></span><br><span class="line"><span class="string">runoob@runoob:~$ docker search -s 10 java</span></span><br><span class="line"><span class="string">NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED</span></span><br><span class="line"><span class="string">java                  Java is a concurrent, class-based...   1037    [OK]       </span></span><br><span class="line"><span class="string">anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]</span></span><br><span class="line"><span class="string">develar/java                                                 46                 [OK]</span></span><br><span class="line"><span class="string">isuper/java-oracle    This repository contains all java...   38                 [OK]</span></span><br><span class="line"><span class="string">lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]</span></span><br><span class="line"><span class="string">nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">NAME: 镜像仓库源的名称</span></span><br><span class="line"><span class="string">DESCRIPTION: 镜像的描述</span></span><br><span class="line"><span class="string">OFFICIAL: 是否 docker 官方发布</span></span><br><span class="line"><span class="string">stars: 类似 Github 里面的 star，表示点赞、喜欢的意思</span></span><br><span class="line"><span class="string">AUTOMATED: 自动构建</span></span><br></pre></td></tr></table></figure></div>



<h2 id="1-6-本地镜像管理"><a href="#1-6-本地镜像管理" class="headerlink" title="1.6 本地镜像管理"></a>1.6 本地镜像管理</h2><h3 id="1-6-1-docker-build"><a href="#1-6-1-docker-build" class="headerlink" title="1.6.1 docker build"></a>1.6.1 docker build</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker build 使用此配置生成新的image</span><br><span class="line">build命令可以从Dockerfile和上下文来创建镜像：</span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line">上面的PATH或URL中的文件被称作上下文，build image的过程会先把这些文件传送到docker的服务端来进行的。</span><br><span class="line">如果PATH直接就是一个单独的Dockerfile文件则可以不需要上下文；如果URL是一个Git仓库地址，那么创建image的过程中会自动git <span class="built_in">clone</span>一份到本机的临时目录，它就成为了本次build的上下文。无论指定的PATH是什么，Dockerfile是至关重要的，请参考Dockerfile Reference。</span><br><span class="line">请看下面的例子：</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat Dockerfile </span></span><br><span class="line">FROM seanlook/nginx:bash_vim</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT /usr/sbin/nginx -c /etc/nginx/nginx.conf &amp;&amp; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker build -t seanlook/nginx:bash_vim_Df .</span></span><br><span class="line">Sending build context to Docker daemon 73.45 MB</span><br><span class="line">Sending build context to Docker daemon </span><br><span class="line">Step 0 : FROM seanlook/nginx:bash_vim</span><br><span class="line"> ---&gt; aa8516fa0bb7</span><br><span class="line">Step 1 : EXPOSE 80</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fece07e2b515</span><br><span class="line">Step 2 : ENTRYPOINT /usr/sbin/nginx -c /etc/nginx/nginx.conf &amp;&amp; /bin/bash</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e08963fd5afb</span><br><span class="line"> ---&gt; d9bbd13f5066</span><br><span class="line">Removing intermediate container e08963fd5afb</span><br><span class="line">Successfully built d9bbd13f5066</span><br><span class="line">上面的PATH为.，所以在当前目录下的所有文件（不包括.dockerignore中的）将会被tar打包并传送到docker daemon（一般在本机），从输出我们可以到Sending build context...，最后有个Removing intermediate container的过程，可以通过--rm=<span class="literal">false</span>来保留容器。</span><br><span class="line">TO-DO</span><br><span class="line">docker build github.com/creack/docker-firefox失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build 命令用于使用 Dockerfile 创建镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">--build-arg=[] :设置镜像创建时的变量；</span><br><span class="line">--cpu-shares :设置 cpu 使用权重；</span><br><span class="line">--cpu-period :限制 CPU CFS周期；</span><br><span class="line">--cpu-quota :限制 CPU CFS配额；</span><br><span class="line">--cpuset-cpus :指定使用的CPU id；</span><br><span class="line">--cpuset-mems :指定使用的内存 id；</span><br><span class="line">--<span class="built_in">disable</span>-content-trust :忽略校验，默认开启；</span><br><span class="line">-f :指定要使用的Dockerfile路径；</span><br><span class="line">--force-rm :设置镜像过程中删除中间容器；</span><br><span class="line">--isolation :使用容器隔离技术；</span><br><span class="line">--label=[] :设置镜像使用的元数据；</span><br><span class="line">-m :设置内存最大值；</span><br><span class="line">--memory-swap :设置Swap的最大值为内存+swap，<span class="string">"-1"</span>表示不限swap；</span><br><span class="line">--no-cache :创建镜像的过程不使用缓存；</span><br><span class="line">--pull :尝试去更新镜像的新版本；</span><br><span class="line">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class="line">--rm :设置镜像成功后删除中间容器；</span><br><span class="line">--shm-size :设置/dev/shm的大小，默认值是64M；</span><br><span class="line">--<span class="built_in">ulimit</span> :Ulimit配置。</span><br><span class="line">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 .</span><br><span class="line"></span><br><span class="line">使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line"></span><br><span class="line">也可以通过 -f Dockerfile 文件的位置：</span><br><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br><span class="line"></span><br><span class="line">在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</span><br><span class="line">$ docker build -t <span class="built_in">test</span>/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-2-docker-images"><a href="#1-6-2-docker-images" class="headerlink" title="1.6.2 docker images"></a>1.6.2 docker images</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">-- 列出机器上的镜像（images）</span><br><span class="line"><span class="comment"># docker images </span></span><br><span class="line">REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZE</span><br><span class="line">ubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB</span><br><span class="line">…</span><br><span class="line">其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于username/repos_name表示Github的个人公共库，类似于regsistory.example.com:5000/repos_name则表示的是私服。</span><br><span class="line">IMAGE ID列其实是缩写，要显示完整则带上--no-trunc选项</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br><span class="line"></span><br><span class="line">同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker images : 列出本地镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</span><br><span class="line">--digests :显示镜像的摘要信息；</span><br><span class="line">-f :显示满足条件的镜像；</span><br><span class="line">--format :指定返回值的模板文件；</span><br><span class="line">--no-trunc :显示完整的镜像信息；</span><br><span class="line">-q :只显示镜像ID</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看本地镜像列表</span><br><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql                 v1                  37af1236adef        5 minutes ago       329 MB</span><br><span class="line">runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB</span><br><span class="line">&lt;none&gt;                  &lt;none&gt;              5c6e1090e771        2 days ago          165.9 MB</span><br><span class="line">httpd                   latest              ed38aaffef30        11 days ago         195.1 MB</span><br><span class="line">alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB</span><br><span class="line">mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB</span><br><span class="line">redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB</span><br><span class="line">php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB</span><br><span class="line">python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">root@runoob:~<span class="comment"># docker images  ubuntu</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-3-docker-rmi"><a href="#1-6-3-docker-rmi" class="headerlink" title="1.6.3 docker rmi"></a>1.6.3 docker rmi</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">删除一个或多个container、image（rm、rmi）</span><br><span class="line">你可能在使用过程中会build或commit许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：</span><br><span class="line"></span><br><span class="line">同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；</span><br><span class="line">承上，如果要删除的多个IMAGE NAME在同一个REPOSITORY，可以通过docker rmi &lt;image_id&gt;来同时删除剩下的TAG；若在不同Repo则还是需要手动逐个删除TAG；</span><br><span class="line">还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像；</span><br><span class="line">TO-DO</span><br><span class="line">如何查看镜像与容器的依存关系</span><br><span class="line"></span><br><span class="line">删除容器</span><br><span class="line">docker rm &lt;container_id/contaner_name&gt;</span><br><span class="line"></span><br><span class="line">删除所有停止的容器</span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line">删除镜像</span><br><span class="line">docker rmi &lt;image_id/image_name ...&gt;</span><br><span class="line">下面是一个完整的示例：</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images            &lt;==</span></span><br><span class="line">ubuntu            13.10        195eb90b5349       4 months ago       184.6 MB</span><br><span class="line">ubuntu            saucy        195eb90b5349       4 months ago       184.6 MB</span><br><span class="line">seanlook/ubuntu   rm_test      195eb90b5349       4 months ago       184.6 MB</span><br><span class="line"></span><br><span class="line">使用195eb90b5349启动、停止一个容器后，删除这个镜像</span><br><span class="line"><span class="comment"># docker rmi 195eb90b5349</span></span><br><span class="line">Error response from daemon: Conflict, cannot delete image 195eb90b5349 because it is </span><br><span class="line">tagged <span class="keyword">in</span> multiple repositories, use -f to force</span><br><span class="line">2014/11/04 14:19:00 Error: failed to remove one or more images</span><br><span class="line"></span><br><span class="line">删除seanlook仓库中的tag     &lt;==</span><br><span class="line"><span class="comment"># docker rmi seanlook/ubuntu:rm_test</span></span><br><span class="line">Untagged: seanlook/ubuntu:rm_test</span><br><span class="line"></span><br><span class="line">现在删除镜像，还会由于container的存在不能rmi</span><br><span class="line"><span class="comment"># docker rmi 195eb90b5349</span></span><br><span class="line">Error response from daemon: Conflict, cannot delete 195eb90b5349 because the </span><br><span class="line"> container eef3648a6e77 is using it, use -f to force</span><br><span class="line">2014/11/04 14:24:15 Error: failed to remove one or more images</span><br><span class="line"></span><br><span class="line">先删除由这个镜像启动的容器    &lt;==</span><br><span class="line"><span class="comment"># docker rm eef3648a6e77</span></span><br><span class="line"></span><br><span class="line">删除镜像                    &lt;==</span><br><span class="line"><span class="comment"># docker rmi 195eb90b5349</span></span><br><span class="line">Deleted: 195eb90b534950d334188c3627f860fbdf898e224d8a0a11ec54ff453175e081</span><br><span class="line">Deleted: 209ea56fda6dc2fb013e4d1e40cb678b2af91d1b54a71529f7df0bd867adc961</span><br><span class="line">Deleted: 0f4aac48388f5d65a725ccf8e7caada42f136026c566528a5ee9b02467dac90a</span><br><span class="line">Deleted: fae16849ebe23b48f2bedcc08aaabd45408c62b531ffd8d3088592043d5e7364</span><br><span class="line">Deleted: f127542f0b6191e99bb015b672f5cf48fa79d974784ac8090b11aeac184eaaff</span><br><span class="line">注意，上面的删除过程我所举的例子比较特殊——镜像被tag在多个仓库，也有启动过的容器。按照&lt;==指示的顺序进行即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker rmi : 删除本地一个或多少镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :强制删除；</span><br><span class="line">--no-prune :不移除该镜像的过程镜像，默认移除；</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">强制删除本地镜像 runoob/ubuntu:v4</span><br><span class="line"></span><br><span class="line">root@runoob:~<span class="comment"># docker rmi -f runoob/ubuntu:v4</span></span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br><span class="line"></span><br><span class="line">docker prune 命令</span><br><span class="line">prune 命令用来删除不再使用的 docker 对象。</span><br><span class="line"></span><br><span class="line">删除所有未被 tag 标记和未被容器使用的镜像:</span><br><span class="line">$ docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line"></span><br><span class="line">删除所有未被容器使用的镜像:</span><br><span class="line">$ docker image prune -a</span><br><span class="line"></span><br><span class="line">删除所有停止运行的容器:</span><br><span class="line">$ docker container prune</span><br><span class="line"></span><br><span class="line">删除所有未被挂载的卷:</span><br><span class="line">$ docker volume prune</span><br><span class="line"></span><br><span class="line">删除所有网络:</span><br><span class="line">$ docker network prune</span><br><span class="line"></span><br><span class="line">删除 docker 所有资源:</span><br><span class="line">$ docker system prune</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-4-docker-tag"><a href="#1-6-4-docker-tag" class="headerlink" title="1.6.4 docker tag"></a>1.6.4 docker tag</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">给镜像打上标签（tag）</span><br><span class="line">tag的作用主要有两点：一是为镜像起一个容易理解的名字，二是可以通过docker tag来重新指定镜像的仓库，这样在push时自动提交到仓库。</span><br><span class="line"></span><br><span class="line">将同一IMAGE_ID的所有tag，合并为一个新的</span><br><span class="line"><span class="comment"># docker tag 195eb90b5349 seanlook/ubuntu:rm_test</span></span><br><span class="line"></span><br><span class="line">新建一个tag，保留旧的那条记录</span><br><span class="line"><span class="comment"># docker tag Registry/Repos:Tag New_Registry/New_Repos:New_Tag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker tag : 标记本地镜像，将其归入某一仓库</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line"></span><br><span class="line">root@runoob:~<span class="comment"># docker tag ubuntu:15.10 runoob/ubuntu:v3</span></span><br><span class="line">root@runoob:~<span class="comment"># docker images   runoob/ubuntu:v3</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-5-docker-save"><a href="#1-6-5-docker-save" class="headerlink" title="1.6.5 docker save"></a>1.6.5 docker save</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker save : 将指定镜像保存成 tar 归档文件</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">OPTIONS 说明：</span><br><span class="line">-o :输出到的文件</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br><span class="line"></span><br><span class="line">docker 镜像导入导出有两种方法：</span><br><span class="line">一种是使用 save 和 load 命令</span><br><span class="line"></span><br><span class="line">使用例子如下：</span><br><span class="line">docker save ubuntu:load&gt;/root/ubuntu.tar</span><br><span class="line">docker load &lt; ubuntu.tar</span><br><span class="line"></span><br><span class="line">一种是使用 <span class="built_in">export</span> 和 import 命令</span><br><span class="line">使用例子如下：</span><br><span class="line">docker <span class="built_in">export</span> 98ca36 &gt; ubuntu.tar</span><br><span class="line">cat ubuntu.tar | sudo docker import - ubuntu:import</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-6-docker-import"><a href="#1-6-6-docker-import" class="headerlink" title="1.6.6 docker import"></a>1.6.6 docker import</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker import : 从归档文件中创建镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-c :应用docker 指令创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-7-docker-load"><a href="#1-6-7-docker-load" class="headerlink" title="1.6.7 docker load"></a>1.6.7 docker load</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker load : 导入使用 docker save 命令导出的镜像</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS 说明：</span><br><span class="line">--input , -i : 指定导入的文件，代替 STDIN。</span><br><span class="line">--quiet , -q : 精简输出信息</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">导入镜像：</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"></span><br><span class="line">$ docker load &lt; busybox.tar.gz</span><br><span class="line">Loaded image: busybox:latest</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">busybox             latest              769b9341d937        7 weeks ago         2.489 MB</span><br><span class="line"></span><br><span class="line">$ docker load --input fedora.tar</span><br><span class="line">Loaded image: fedora:rawhide</span><br><span class="line">Loaded image: fedora:20</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">busybox             latest              769b9341d937        7 weeks ago         2.489 MB</span><br><span class="line">fedora              rawhide             0d20aec6529d        7 weeks ago         387 MB</span><br><span class="line">fedora              20                  58394af37342        7 weeks ago         385.5 MB</span><br><span class="line">fedora              heisenbug           58394af37342        7 weeks ago         385.5 MB</span><br><span class="line">fedora              latest              58394af37342        7 weeks ago         385.5 MB</span><br></pre></td></tr></table></figure></div>



<h2 id="1-7-容器资源管理"><a href="#1-7-容器资源管理" class="headerlink" title="1.7 容器资源管理"></a>1.7 容器资源管理</h2><h3 id="1-7-1-docker-volume"><a href="#1-7-1-docker-volume" class="headerlink" title="1.7.1 docker volume"></a>1.7.1 docker volume</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="1-7-2-docker-network"><a href="#1-7-2-docker-network" class="headerlink" title="1.7.2 docker network"></a>1.7.2 docker network</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h2 id="1-8-系统日志信息"><a href="#1-8-系统日志信息" class="headerlink" title="1.8 系统日志信息"></a>1.8 系统日志信息</h2><h3 id="1-8-1-docker-events"><a href="#1-8-1-docker-events" class="headerlink" title="1.8.1 docker events"></a>1.8.1 docker events</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker events : 从服务器获取实时事件</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker events [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f ：根据条件过滤事件；</span><br><span class="line">--since ：从指定的时间戳后显示所有事件;</span><br><span class="line">--until ：流水时间显示到指定的时间为止；</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">显示docker 2016年7月1日后的所有事件</span><br><span class="line">runoob@runoob:~/mysql$ docker events  --since=<span class="string">"1467302400"</span></span><br><span class="line">2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, <span class="built_in">type</span>=bridge)</span><br><span class="line">2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)</span><br><span class="line">2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)</span><br><span class="line">2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">runoob@runoob:~/mysql$ docker events -f <span class="string">"image"</span>=<span class="string">"mysql:5.6"</span> --since=<span class="string">"1467302400"</span> </span><br><span class="line">2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.022572452+08:00 container <span class="built_in">kill</span> 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)</span><br><span class="line">2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line"></span><br><span class="line">如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如--since=<span class="string">"2016-07-01"</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[时间转换时间戳]</span><br><span class="line"></span><br><span class="line">A.将日期转换为Unix时间戳</span><br><span class="line">将当前时间以Unix时间戳表示：</span><br><span class="line">date +%s</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">1361542433</span><br><span class="line"></span><br><span class="line">转换指定日期为Unix时间戳：</span><br><span class="line">date -d <span class="string">'2013-2-22 22:14'</span> +%s</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">1361542440</span><br><span class="line"></span><br><span class="line">B.将Unix时间戳转换为日期时间</span><br><span class="line">不指定日期时间的格式：</span><br><span class="line">date -d @1361542596</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">Fri Feb 22 22:16:36 CST 2013</span><br><span class="line"></span><br><span class="line">指定日期格式的转换：</span><br><span class="line">date -d @1361542596 +<span class="string">"%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">2013-02-22 22:16:36</span><br></pre></td></tr></table></figure></div>

<h3 id="1-8-2-docker-history"><a href="#1-8-2-docker-history" class="headerlink" title="1.8.2 docker history"></a>1.8.2 docker history</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">history</span> : 查看指定镜像的创建历史</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-H :以可读的格式打印镜像大小和日期，默认为<span class="literal">true</span>；</span><br><span class="line">--no-trunc :显示完整的提交记录；</span><br><span class="line">-q :仅列出提交记录ID</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~<span class="comment"># docker history runoob/ubuntu:v3</span></span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c <span class="comment">#(nop) CMD ["/bin/bash"]             0 B                 </span></span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i <span class="string">'s/^#\s*\(deb.*universe\)$/   1.863 kB            </span></span><br><span class="line"><span class="string">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo '</span><span class="comment">#!/bin/sh' &gt; /u   701 B               </span></span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c <span class="comment">#(nop) ADD file:43cb048516c6b80f22   136.3 MB</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-8-3-docker-logs"><a href="#1-8-3-docker-logs" class="headerlink" title="1.8.3 docker logs"></a>1.8.3 docker logs</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">docker logs : 获取容器的日志</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f : 跟踪日志输出</span><br><span class="line">--since :显示某个开始时间的所有日志</span><br><span class="line">-t : 显示时间戳</span><br><span class="line">--tail :仅列出最新N条容器日志</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">跟踪查看容器mynginx的日志输出</span><br><span class="line">runoob@runoob:~$ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] <span class="string">"GET / HTTP/1.1"</span> 200 612 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36"</span> <span class="string">"-"</span></span><br><span class="line">2016/07/10 16:53:33 [error] 5<span class="comment">#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"</span></span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 571 <span class="string">"http://192.168.239.130/"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36"</span> <span class="string">"-"</span></span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] <span class="string">"GET / HTTP/1.1"</span> 304 0 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36"</span> <span class="string">"-"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=<span class="string">"2016-07-01"</span> --tail=10 mynginx</span><br></pre></td></tr></table></figure></div>

<h1 id="二-Docker-资源汇总"><a href="#二-Docker-资源汇总" class="headerlink" title="二. Docker 资源汇总"></a>二. Docker 资源汇总</h1><h2 id="2-1-Docker-资源"><a href="#2-1-Docker-资源" class="headerlink" title="2.1 Docker 资源"></a>2.1 Docker 资源</h2><ul>
<li>Docker 官方主页: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></li>
<li>Docker 官方博客: <a href="https://blog.docker.com/" target="_blank" rel="noopener">https://blog.docker.com/</a></li>
<li>Docker 官方文档: <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li>
<li>Docker Store: <a href="https://store.docker.com/" target="_blank" rel="noopener">https://store.docker.com</a></li>
<li>Docker Cloud: <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com</a></li>
<li>Docker Hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a></li>
<li>Docker 的源代码仓库: <a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
<li>Docker 发布版本历史: <a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">https://docs.docker.com/release-notes/</a></li>
<li>Docker 常见问题: <a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">https://docs.docker.com/engine/faq/</a></li>
<li>Docker 远端应用 API: <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a></li>
</ul>
<h2 id="2-2-Docker-国内镜像"><a href="#2-2-Docker-国内镜像" class="headerlink" title="2.2 Docker 国内镜像"></a>2.2 Docker 国内镜像</h2><ul>
<li>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/60750.html</a></li>
<li>网易加速器：<a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></li>
<li>官方中国加速器：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li>
<li>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></li>
<li>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc（注册后使用）" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li>
</ul>
<h2 id="2-3-Docker-常用案例"><a href="#2-3-Docker-常用案例" class="headerlink" title="2.3 Docker 常用案例"></a>2.3 Docker 常用案例</h2><h3 id="2-3-1-Hello-World"><a href="#2-3-1-Hello-World" class="headerlink" title="2.3.1 Hello World"></a>2.3.1 Hello World</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序</span><br><span class="line"></span><br><span class="line">输出Hello world</span><br><span class="line">runoob@runoob:~$ docker run ubuntu:15.10 /bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span></span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">各个参数解析：</span><br><span class="line">  docker: Docker 的二进制执行文件。</span><br><span class="line">  run: 与前面的 docker 组合来运行一个容器。</span><br><span class="line">  ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</span><br><span class="line">  /bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span>: 在启动的容器里执行的命令</span><br><span class="line"></span><br><span class="line">以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span>，然后输出结果</span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-2-运行交互式的容器"><a href="#2-3-2-运行交互式的容器" class="headerlink" title="2.3.2 运行交互式的容器"></a>2.3.2 运行交互式的容器</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现<span class="string">"对话"</span>的能力</span><br><span class="line"></span><br><span class="line">$ docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line">root@0123ce188bd8:/<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">各个参数解析：</span><br><span class="line">-t: 在新容器内指定一个伪终端或终端。</span><br><span class="line">-i: 允许你对容器内的标准输入 (STDIN) 进行交互</span><br><span class="line"></span><br><span class="line">注意第二行 root@0123ce188bd8:/<span class="comment">#，此时我们已进入一个 ubuntu15.10 系统的容器</span></span><br><span class="line">我们尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表</span><br><span class="line">root@0123ce188bd8:/<span class="comment">#  cat /proc/version</span></span><br><span class="line">Linux version 4.4.0-151-generic (buildd@lgw01-amd64-043) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10) ) <span class="comment">#178-Ubuntu SMP Tue Jun 11 08:30:22 UTC 2019</span></span><br><span class="line">root@0123ce188bd8:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@0123ce188bd8:/<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">我们可以通过运行 <span class="built_in">exit</span> 命令或者使用 CTRL+D 来退出容器</span><br><span class="line">root@0123ce188bd8:/<span class="comment">#  exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">root@runoob:~<span class="comment"># </span></span><br><span class="line">注意第三行中 root@runoob:~<span class="comment"># 表明我们已经退出了当期的容器，返回到当前的主机中</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-3-启动容器（后台模式）"><a href="#2-3-3-启动容器（后台模式）" class="headerlink" title="2.3.3 启动容器（后台模式）"></a>2.3.3 启动容器（后台模式）</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">使用以下命令创建一个以进程方式运行的容器</span><br><span class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</span><br><span class="line"></span><br><span class="line">在输出中，我们没有看到期望的 <span class="string">"hello world"</span>，而是一串长字符</span><br><span class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</span><br><span class="line">这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</span><br><span class="line">首先，我们需要确认容器有在运行，可以通过 docker ps 来查看：</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND              ...  </span><br><span class="line">5917eac21c36        ubuntu:15.10           <span class="string">"/bin/sh -c 'while t…"</span>    ...</span><br><span class="line"></span><br><span class="line">输出详情介绍：</span><br><span class="line"></span><br><span class="line">CONTAINER ID: 容器 ID。</span><br><span class="line">IMAGE: 使用的镜像。</span><br><span class="line">COMMAND: 启动容器时运行的命令。</span><br><span class="line">CREATED: 容器的创建时间。</span><br><span class="line">STATUS: 容器状态。</span><br><span class="line"> 状态有7种：</span><br><span class="line">   created（已创建）</span><br><span class="line">   restarting（重启中）</span><br><span class="line">   running（运行中）</span><br><span class="line">   removing（迁移中）</span><br><span class="line">   paused（暂停）</span><br><span class="line">   exited（停止）</span><br><span class="line">   dead（死亡）</span><br><span class="line">   </span><br><span class="line">PORTS: 容器的端口信息和使用的连接类型（tcp\udp）</span><br><span class="line">NAMES: 自动分配的容器名称</span><br><span class="line"></span><br><span class="line">在宿主主机内使用 docker logs 命令，查看容器内的标准输出：</span><br><span class="line">runoob@runoob:~$ docker logs 2b1b7a428627</span><br><span class="line">runoob@runoob:~$ docker logs amazing_cori</span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-4-停止容器"><a href="#2-3-4-停止容器" class="headerlink" title="2.3.4 停止容器"></a>2.3.4 停止容器</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">使用 docker stop 命令来停止容器:</span><br><span class="line">$ docker stop 2bxxxxxxxx</span><br><span class="line"></span><br><span class="line">通过 docker ps 查看，容器已经停止工作</span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">也可以用下面的命令来停止:</span><br><span class="line">$ docker stop amazing_cori</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-5-Docker-容器使用"><a href="#2-3-5-Docker-容器使用" class="headerlink" title="2.3.5 Docker 容器使用"></a>2.3.5 Docker 容器使用</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">通过命令 docker <span class="built_in">command</span> --<span class="built_in">help</span> 可以了解命令使用方法</span><br><span class="line"></span><br><span class="line">查看 docker stats 指令的具体使用方法</span><br><span class="line"><span class="comment"># docker stats --help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[容器使用]</span><br><span class="line">获取镜像，如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</span><br><span class="line">$ docker pull ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[启动容器]</span><br><span class="line">以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</span><br><span class="line">$ docker run -it ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-i: 交互式操作</span><br><span class="line">-t: 终端</span><br><span class="line">ubuntu: ubuntu 镜像</span><br><span class="line">/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</span><br><span class="line"></span><br><span class="line">要退出终端，直接输入 <span class="built_in">exit</span>:</span><br><span class="line">root@ed09e4490c57:/<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[启动已停止运行的容器]</span><br><span class="line"></span><br><span class="line">查看所有的容器命令如下：</span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">使用 docker start 启动一个已停止的容器：</span><br><span class="line">$ docker start b750bbbcfd88</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[后台运行]</span><br><span class="line">在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式</span><br><span class="line"></span><br><span class="line">$ docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker <span class="built_in">exec</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[停止一个容器]</span><br><span class="line">$ docker stop &lt;容器 ID&gt;</span><br><span class="line"></span><br><span class="line">停止的容器可以通过 docker restart 重启：</span><br><span class="line">$ docker restart &lt;容器 ID&gt;</span><br><span class="line"></span><br><span class="line">[进入容器]</span><br><span class="line">在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</span><br><span class="line">  docker attach</span><br><span class="line">  docker <span class="built_in">exec</span>：推荐大家使用 docker <span class="built_in">exec</span> 命令，因为此退出容器终端，不会导致容器的停止</span><br><span class="line"></span><br><span class="line">attach 命令</span><br><span class="line">$ docker attach 1e560fca3906 </span><br><span class="line">注意： 如果从这个容器退出，会导致容器的停止</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> 命令</span><br><span class="line">$ docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br><span class="line"></span><br><span class="line">注意： 如果从这个容器退出，不会导致容器的停止，这就是推荐使用 docker <span class="built_in">exec</span> 的原因</span><br><span class="line">参考：docker <span class="built_in">exec</span> --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">[导出和导入容器]</span><br><span class="line">导出容器</span><br><span class="line">如果要导出本地某个容器，可以使用 docker <span class="built_in">export</span> 命令</span><br><span class="line">$ docker <span class="built_in">export</span> 1e560fca3906 &gt; ubuntu.tar</span><br><span class="line">这样将导出容器快照到本地文件</span><br><span class="line"></span><br><span class="line">导入容器快照</span><br><span class="line">可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 <span class="built_in">test</span>/ubuntu:v1:</span><br><span class="line">$ cat docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br><span class="line"></span><br><span class="line">此外，也可以通过指定 URL 或者某个目录来导入</span><br><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[删除容器]</span><br><span class="line">删除容器使用 docker rm 命令</span><br><span class="line">$ docker rm -f 1e560fca3906</span><br><span class="line"></span><br><span class="line">下面的命令可以清理掉所有处于终止状态的容器</span><br><span class="line">$ docker container prune</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[运行一个 web 应用]</span><br><span class="line"></span><br><span class="line">前面我们运行的容器并没有一些什么特别的用处。</span><br><span class="line">接下来让我们尝试使用 docker 构建一个 web 应用程序。</span><br><span class="line">我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用</span><br><span class="line"></span><br><span class="line">runoob@runoob:~<span class="comment"># docker pull training/webapp  # 载入镜像</span></span><br><span class="line">runoob@runoob:~<span class="comment"># docker run -d -P training/webapp python app.py</span></span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">-d:让容器在后台运行。</span><br><span class="line">-P:将容器内部使用的网络端口映射到我们使用的主机上。</span><br><span class="line"></span><br><span class="line">[查看 WEB 应用容器]</span><br><span class="line">使用 docker ps 来查看我们正在运行的容器：</span><br><span class="line">runoob@runoob:~<span class="comment">#  docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 </span><br><span class="line">d3d5e39ed9d3        training/webapp     <span class="string">"python app.py"</span>     ...        0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line"></span><br><span class="line">这里多了端口信息</span><br><span class="line">PORTS</span><br><span class="line">0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line"></span><br><span class="line">Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上</span><br><span class="line"></span><br><span class="line">通过浏览器访问WEB应用</span><br><span class="line">http://xx.xx.xx.xx:32769</span><br><span class="line"></span><br><span class="line">我们也可以通过 -p 参数来设置不一样的端口：</span><br><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line">docker ps查看正在运行的容器</span><br><span class="line">runoob@runoob:~<span class="comment">#  docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                             PORTS                     NAMES</span><br><span class="line">bf08b7f2cd89        training/webapp     ...        0.0.0.0:5000-&gt;5000/tcp    wizardly_chandrasekhar</span><br><span class="line">d3d5e39ed9d3        training/webapp     ...        0.0.0.0:32769-&gt;5000/tcp   xenodochial_hoov</span><br><span class="line"></span><br><span class="line">容器内部的 5000 端口映射到我们本地主机的 5000 端口上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[网络端口的快捷方式]</span><br><span class="line"></span><br><span class="line">通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，</span><br><span class="line">使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</span><br><span class="line"></span><br><span class="line">上面创建的 web 应用容器 ID 为 bf08b7f2cd89 名字为 wizardly_chandrasekhar</span><br><span class="line"></span><br><span class="line">我可以使用 docker port bf08b7f2cd89 或 docker port wizardly_chandrasekhar 来查看容器端口的映射情况</span><br><span class="line"></span><br><span class="line">$ docker port bf08b7f2cd89</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line"></span><br><span class="line">$ docker port wizardly_chandrasekhar</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[查看 WEB 应用程序日志]</span><br><span class="line"></span><br><span class="line">docker logs [ID或者名字] 可以查看容器内部的标准输出</span><br><span class="line">runoob@runoob:~$ docker logs -f bf08b7f2cd89</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] <span class="string">"GET / HTTP/1.1"</span> 200 -</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 -</span><br><span class="line"></span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</span><br><span class="line">从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</span><br><span class="line"></span><br><span class="line">[查看WEB应用程序容器的进程]</span><br><span class="line">我们还可以使用 docker top 来查看容器内部运行的进程</span><br><span class="line"></span><br><span class="line">$ docker top wizardly_chandrasekhar</span><br><span class="line">UID     PID         PPID          ...       TIME                CMD</span><br><span class="line">root    23245       23228         ...       00:00:00            python app.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[检查 WEB 应用程序]</span><br><span class="line"></span><br><span class="line">使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span><br><span class="line">$ docker inspect wizardly_chandrasekhar</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2018-09-17T01:41:26.174228707Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"python"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [</span><br><span class="line">            <span class="string">"app.py"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: 23245,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2018-09-17T01:41:26.494185806Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[停止 WEB 应用容器]</span><br><span class="line">$ docker stop wizardly_chandrasekhar   </span><br><span class="line">wizardly_chandrasekhar</span><br><span class="line"></span><br><span class="line">[重启WEB应用容器]</span><br><span class="line">已经停止的容器，我们可以使用命令 docker start 来启动</span><br><span class="line">$ docker start wizardly_chandrasekhar</span><br><span class="line">wizardly_chandrasekhar</span><br><span class="line"></span><br><span class="line">docker ps -l 查询最后一次创建的容器</span><br><span class="line"><span class="comment">#  docker ps -l </span></span><br><span class="line">CONTAINER ID        IMAGE                             PORTS                     NAMES</span><br><span class="line">bf08b7f2cd89        training/webapp     ...        0.0.0.0:5000-&gt;5000/tcp    wizardly_chandrasekhar</span><br><span class="line"></span><br><span class="line">正在运行的容器，我们可以使用 docker restart 命令来重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[移除WEB应用容器]</span><br><span class="line">使用 docker rm 命令来删除不需要的容器</span><br><span class="line">$ docker rm wizardly_chandrasekhar  </span><br><span class="line">wizardly_chandrasekhar</span><br><span class="line"></span><br><span class="line">删除容器时，容器必须是停止状态，否则会报如下错误</span><br><span class="line">$ docker rm wizardly_chandrasekhar</span><br><span class="line">Error response from daemon: You cannot remove a running container bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85. Stop the container before attempting removal or force remove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ 权限问题报错：]</span><br><span class="line">安装完docker后，执行docker相关命令，出现：</span><br><span class="line">”Got permission denied <span class="keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.26/images/json: dial unix /var/run/docker.sock: connect: permission denied“</span><br><span class="line"></span><br><span class="line">原因</span><br><span class="line">摘自docker mannual上的一段话：</span><br><span class="line">---</span><br><span class="line">Manage Docker as a non-root user</span><br><span class="line"></span><br><span class="line">The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.</span><br><span class="line"></span><br><span class="line">If you don’t want to use sudo when you use the docker <span class="built_in">command</span>, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket <span class="built_in">read</span>/writable by the docker group</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">大概的意思就是：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</span><br><span class="line"></span><br><span class="line">解决方法1</span><br><span class="line">使用sudo获取管理员权限，运行docker命令</span><br><span class="line"></span><br><span class="line">解决方法2</span><br><span class="line">docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</span><br><span class="line"></span><br><span class="line">sudo groupadd docker             <span class="comment"># 添加docker用户组</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker     <span class="comment"># 将登陆用户加入到docker用户组中</span></span><br><span class="line">newgrp docker                    <span class="comment"># 更新用户组</span></span><br><span class="line">docker ps                        <span class="comment"># 测试docker命令是否可以使用sudo正常使用</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-6-Docker-镜像使用"><a href="#2-3-6-Docker-镜像使用" class="headerlink" title="2.3.6 Docker 镜像使用"></a>2.3.6 Docker 镜像使用</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</span><br><span class="line"></span><br><span class="line">1. 管理和使用本地 Docker 主机镜像</span><br><span class="line">2. 创建镜像</span><br><span class="line"></span><br><span class="line">[列出镜像列表]</span><br><span class="line">可以使用 docker images 来列出本地主机上的镜像</span><br><span class="line">runoob@runoob:~$ docker images           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        11 months ago       348.8 MB</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line">  REPOSITORY：表示镜像的仓库源</span><br><span class="line">  TAG：镜像的标签</span><br><span class="line">  IMAGE ID：镜像ID</span><br><span class="line">  CREATED：镜像创建时间</span><br><span class="line">  SIZE：镜像大小</span><br><span class="line"></span><br><span class="line">同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</span><br><span class="line"></span><br><span class="line">所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</span><br><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash </span><br><span class="line">root@d77ccb2e5cca:/<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">  -i: 交互式操作。</span><br><span class="line">  -t: 终端。</span><br><span class="line">  ubuntu:15.10: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</span><br><span class="line">  /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</span><br><span class="line">  </span><br><span class="line">如果要使用版本为 14.04 的 ubuntu 系统镜像来运行容器时，命令如下：</span><br><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:14.04 /bin/bash </span><br><span class="line">root@39e968165990:/<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[获取一个新的镜像]</span><br><span class="line">当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</span><br><span class="line"></span><br><span class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</span><br><span class="line">13.10: Pulling from library/ubuntu</span><br><span class="line">6599cadaf950: Pull complete </span><br><span class="line">23eda618d451: Pull complete </span><br><span class="line">f0be3084efe9: Pull complete </span><br><span class="line">52de432f084b: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">Digest: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:13.10</span><br><span class="line">下载完成后，可以直接使用这个镜像来运行容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[查找镜像]</span><br><span class="line">我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/</span><br><span class="line">我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</span><br><span class="line">runoob@runoob:~$  docker search httpd</span><br><span class="line"></span><br><span class="line">NAME: 镜像仓库源的名称</span><br><span class="line">DESCRIPTION: 镜像的描述</span><br><span class="line">OFFICIAL: 是否 docker 官方发布</span><br><span class="line">stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span><br><span class="line">AUTOMATED: 自动构建</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[拉取镜像]</span><br><span class="line">$ docker pull httpd</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/httpd</span><br><span class="line">8b87079b7a06: Pulling fs layer </span><br><span class="line">a3ed95caeb02: Download complete </span><br><span class="line">0d62ec9c6a76: Download complete </span><br><span class="line">a329d50397b9: Download complete </span><br><span class="line">ea7c1f032b5c: Waiting </span><br><span class="line">be44112b72c7: Waiting</span><br><span class="line"></span><br><span class="line">$ docker run httpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[删除镜像]</span><br><span class="line">镜像删除使用 docker rmi 命令，比如我们删除 hello-world 镜像</span><br><span class="line">$ docker rmi hello-world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[创建镜像]</span><br><span class="line">当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改</span><br><span class="line">1、从已经创建的容器中更新镜像，并且提交这个镜像</span><br><span class="line">2、使用 Dockerfile 指令来创建一个新的镜像</span><br><span class="line"></span><br><span class="line">更新镜像</span><br><span class="line">更新镜像之前，我们需要使用镜像来创建一个容器。</span><br><span class="line">$ docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">root@e218edb10161:/<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">在运行的容器内使用 apt-get update 命令进行更新</span><br><span class="line">在完成操作之后，输入 <span class="built_in">exit</span> 命令来退出这个容器</span><br><span class="line"></span><br><span class="line">此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本</span><br><span class="line">runoob@runoob:~$ docker commit -m=<span class="string">"has update"</span> -a=<span class="string">"runoob"</span> e218edb10161 runoob/ubuntu:v2</span><br><span class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br><span class="line"></span><br><span class="line">各个参数说明：</span><br><span class="line">  -m: 提交的描述信息</span><br><span class="line">  -a: 指定镜像作者</span><br><span class="line">  e218edb10161：容器 ID</span><br><span class="line">  runoob/ubuntu:v2: 指定要创建的目标镜像名</span><br><span class="line"></span><br><span class="line">我们可以使用 docker images 命令来查看我们的新镜像 runoob/ubuntu:v2：</span><br><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        15 seconds ago      158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago       348.8 MB</span><br><span class="line"></span><br><span class="line">使用我们的新镜像 runoob/ubuntu 来启动一个容器</span><br><span class="line">$ docker run -t -i runoob/ubuntu:v2 /bin/bash                            </span><br><span class="line">root@1a9fbdeb5da3:/<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[构建镜像]</span><br><span class="line">我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</span><br><span class="line">runoob@runoob:~$ cat Dockerfile </span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher <span class="string">"fisher@sudops.com"</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'runoob:123456'</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">"LANG=\"en_US.UTF-8\""</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</span><br><span class="line">第一条FROM，指定使用哪个镜像源</span><br><span class="line">RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</span><br><span class="line">然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</span><br><span class="line">Sending build context to Docker daemon 17.92 kB</span><br><span class="line">Step 1 : FROM centos:6.7</span><br><span class="line"> ---&amp;gt; d95b5ca17cc3</span><br><span class="line">Step 2 : MAINTAINER Fisher <span class="string">"fisher@sudops.com"</span></span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0c92299c6f03</span><br><span class="line">Step 3 : RUN /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0397ce2fbd0a</span><br><span class="line">Step 4 : RUN useradd runoob</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-t ：指定要创建的目标镜像名</span><br><span class="line">. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</span><br><span class="line"></span><br><span class="line">使用docker images 查看创建的镜像已经在列表中存在,镜像ID为860c279d2fec</span><br><span class="line">runoob@runoob:~$ docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">runoob/centos       6.7                 860c279d2fec        About a minute ago   190.6 MB</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        17 hours ago         158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        6 days ago           188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        10 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago          182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago          324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago          194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        5 weeks ago          136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago         960 B</span><br><span class="line">centos              6.7                 d95b5ca17cc3        6 months ago         190.6 MB</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago        348.8 MB</span><br><span class="line"></span><br><span class="line">我们可以使用新的镜像来创建容器</span><br><span class="line">runoob@runoob:~$ docker run -t -i runoob/centos:6.7  /bin/bash</span><br><span class="line">[root@41c28d18b5fb /]<span class="comment"># id runoob</span></span><br><span class="line">uid=500(runoob) gid=500(runoob) groups=500(runoob)</span><br><span class="line"></span><br><span class="line">从上面看到新镜像已经包含我们创建的用户 runoob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[设置镜像标签]</span><br><span class="line">我们可以使用 docker tag 命令，为镜像添加一个新的标签</span><br><span class="line">$ docker tag 860c279d2fec runoob/centos:dev</span><br><span class="line"></span><br><span class="line">docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</span><br><span class="line">使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        22 hours ago        158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        6 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        10 days ago         444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        13 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        5 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">centos              6.7                 d95b5ca17cc3        6 months ago        190.6 MB</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago       348.8 MB</span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-7-Docker-容器连接"><a href="#2-3-7-Docker-容器连接" class="headerlink" title="2.3.7 Docker 容器连接"></a>2.3.7 Docker 容器连接</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射</span><br><span class="line">下面实现通过端口连接到一个 docker 容器</span><br><span class="line"></span><br><span class="line">[网络端口映射]</span><br><span class="line">创建了一个 python 应用的容器</span><br><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</span><br><span class="line"></span><br><span class="line">可以指定容器绑定的网络地址，比如绑定 127.0.0.1</span><br><span class="line">我们使用 -P 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES</span><br><span class="line">fce072cc88ce    training/webapp     <span class="string">"python app.py"</span>    ...     0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br><span class="line"></span><br><span class="line">我们也可以使用 -p 标识来指定容器端口绑定到主机端口</span><br><span class="line"></span><br><span class="line">两种方式的区别是:</span><br><span class="line">  -P :是容器内部端口随机映射到主机的高端口</span><br><span class="line">  -p : 是容器内部端口绑定到指定的主机端口</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES</span><br><span class="line">33e4523d30aa        training/webapp     <span class="string">"python app.py"</span>   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">"python app.py"</span>   ...   0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br><span class="line"></span><br><span class="line">另外，可以指定容器绑定的网络地址，比如绑定 127.0.0.1</span><br><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line">95c6ceef88ca        training/webapp     <span class="string">"python app.py"</span>   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     <span class="string">"python app.py"</span>   ...  0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">"python app.py"</span>   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br><span class="line"></span><br><span class="line">这样就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口</span><br><span class="line"></span><br><span class="line">上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp</span><br><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line">6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES</span><br><span class="line">6779686f06f6        training/webapp     <span class="string">"python app.py"</span>   ...   5000/tcp, 127.0.0.1:5000-&gt;5000/udp   drunk_visvesvaraya</span><br><span class="line">95c6ceef88ca        training/webapp     <span class="string">"python app.py"</span>   ...    5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     <span class="string">"python app.py"</span>   ...     0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">"python app.py"</span>   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br><span class="line"></span><br><span class="line">docker port 命令可以让我们快捷地查看端口的绑定情况</span><br><span class="line">runoob@runoob:~$ docker port adoring_stonebraker 5000</span><br><span class="line">127.0.0.1:5001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Docker 容器互联]</span><br><span class="line">端口映射并不是唯一把 docker 连接到另一个容器的方法。</span><br><span class="line">docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</span><br><span class="line">docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息</span><br><span class="line"></span><br><span class="line">a) 容器命名</span><br><span class="line"></span><br><span class="line">当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 --name 标识来命名容器，例如：</span><br><span class="line">runoob@runoob:~$  docker run -d -P --name runoob training/webapp python app.py</span><br><span class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</span><br><span class="line"></span><br><span class="line">我们可以使用 docker ps 命令来查看容器名称</span><br><span class="line">runoob@runoob:~$ docker ps -l</span><br><span class="line">CONTAINER ID     IMAGE            COMMAND           ...    PORTS                     NAMES</span><br><span class="line">43780a6eabaa     training/webapp   <span class="string">"python app.py"</span>  ...     0.0.0.0:32769-&gt;5000/tcp   runoob</span><br><span class="line"></span><br><span class="line">b) 新建网络</span><br><span class="line"></span><br><span class="line">先创建一个新的 Docker 网络</span><br><span class="line">$ docker network create -d bridge <span class="built_in">test</span>-net</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-d：参数指定 Docker 网络类型，有 bridge、overlay</span><br><span class="line">其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它</span><br><span class="line"></span><br><span class="line">c) 连接容器</span><br><span class="line">运行一个容器并连接到新建的 <span class="built_in">test</span>-net 网络</span><br><span class="line">$ docker run -itd --name test1 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">打开新的终端，再运行一个容器并加入到 <span class="built_in">test</span>-net 网络</span><br><span class="line">$ docker run -itd --name test2 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</span><br><span class="line">如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）</span><br><span class="line">apt-get update</span><br><span class="line">apt install iputils-ping</span><br><span class="line"></span><br><span class="line">在 test1 容器输入以下命令：</span><br><span class="line">$ docker <span class="built_in">exec</span> -it test1 /bin/bash</span><br><span class="line"><span class="comment"># ping test2</span></span><br><span class="line"></span><br><span class="line">在 test2 容器也会成功连接到 test1</span><br><span class="line">$ docker <span class="built_in">exec</span> -it test2 /bin/bash</span><br><span class="line"><span class="comment"># ping test1</span></span><br><span class="line"></span><br><span class="line">如果你有多个容器之间需要互相连接，推荐使用 Docker Compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[配置 DNS]</span><br><span class="line">可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</span><br><span class="line">配置完，需要重启 docker 才能生效。</span><br><span class="line">查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</span><br><span class="line">$ docker run -it --rm ubuntu  cat etc/resolv.conf</span><br><span class="line"></span><br><span class="line">手动指定容器的配置</span><br><span class="line">如果只想在指定的容器设置 DNS，则可以使用以下命令:</span><br><span class="line">$ docker run -it --rm host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">  -h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts</span><br><span class="line">  --dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名</span><br><span class="line">  --dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com</span><br><span class="line"></span><br><span class="line">如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[解决windows系统无法对docker容器进行端口映射的问题]</span><br><span class="line">1、问题：</span><br><span class="line">在Windows家庭版下安装了docker，并尝试在其中运行jupyter notebook等服务，但映射完毕之后，在主机的浏览器中，打开localhost:port无法访问对应的服务。</span><br><span class="line"></span><br><span class="line">2、问题出现的原因：</span><br><span class="line">The reason you’re having this, is because on Linux, the docker daemon (and your containers) run on the Linux machine itself, so “localhost” is also the host that the container is running on, and the ports are mapped to.</span><br><span class="line"></span><br><span class="line">On Windows (and OS X), the docker daemon, and your containers cannot run natively, so only the docker client is running on your Windows machine, but the daemon (and your containers) run <span class="keyword">in</span> a VirtualBox Virtual Machine, that runs Linux.</span><br><span class="line"></span><br><span class="line">因为docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows。</span><br><span class="line"></span><br><span class="line">3、解决方法：</span><br><span class="line">通过命令</span><br><span class="line">docker-machine ip default   <span class="comment"># 其中，default 是docker-machine的name，可以通过docker-machine -ls 查看</span></span><br><span class="line"></span><br><span class="line">找到这个Linux的ip地址，一般情况下这个地址是192.168.99.100，然后在Windows的浏览器中，输入这个地址，加上服务的端口即可启用了。</span><br><span class="line"></span><br><span class="line">比如，首先运行一个docker 容器：</span><br><span class="line">docker run -it -p 8888:8888 conda:v1</span><br><span class="line"></span><br><span class="line">其中，conda:v1是我的容器名称。然后在容器中开启jupyter notebook 服务：</span><br><span class="line">jupyter notebook --no-browser --port=8888 --ip=172.17.0.2 --allow-root</span><br><span class="line"></span><br><span class="line">其中的ip参数为我的容器的ip地址，可以通过如下命令获得：</span><br><span class="line">docker inspect container_id</span><br><span class="line"></span><br><span class="line">最后在windows浏览器中测试结果：</span><br><span class="line">http://192.168.99.100:8888</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-8-Docker-仓库管理"><a href="#2-3-8-Docker-仓库管理" class="headerlink" title="2.3.8 Docker 仓库管理"></a>2.3.8 Docker 仓库管理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的</span><br><span class="line">https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">Docker Hub</span><br><span class="line">目前 Docker 官方维护了一个公共仓库 Docker Hub https://hub.docker.com/</span><br><span class="line">大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现</span><br><span class="line"></span><br><span class="line">注册</span><br><span class="line">在 https://hub.docker.com 免费注册一个 Docker 账号</span><br><span class="line"></span><br><span class="line">登录和退出</span><br><span class="line">登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像</span><br><span class="line">$ docker login</span><br><span class="line"></span><br><span class="line">退出</span><br><span class="line">退出 docker hub 可以使用以下命令：</span><br><span class="line">$ docker <span class="built_in">logout</span></span><br><span class="line"></span><br><span class="line">拉取镜像</span><br><span class="line">你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</span><br><span class="line">以 ubuntu 为关键词进行搜索：</span><br><span class="line">$ docker search ubuntu</span><br><span class="line"></span><br><span class="line">使用 docker pull 将官方 ubuntu 镜像下载到本地：</span><br><span class="line">$ docker pull ubuntu </span><br><span class="line"></span><br><span class="line">推送镜像</span><br><span class="line">用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub</span><br><span class="line">以下命令中的 username 请替换为你的 Docker 账号用户名</span><br><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username/ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line">$ docker search username/ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-9-Docker-Dockerfile"><a href="#2-3-9-Docker-Dockerfile" class="headerlink" title="2.3.9 Docker Dockerfile"></a>2.3.9 Docker Dockerfile</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">什么是 Dockerfile？</span><br><span class="line">Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[使用 Dockerfile 定制镜像]</span><br><span class="line">这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可</span><br><span class="line"></span><br><span class="line">1. 下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）</span><br><span class="line">在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</span><br><span class="line"></span><br><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'这是一个本地构建的nginx镜像'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">2. FROM 和 RUN 指令的作用</span><br><span class="line">FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</span><br><span class="line">RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</span><br><span class="line">shell 格式：</span><br><span class="line">  RUN &lt;命令行命令&gt;</span><br><span class="line">  <span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令</span></span><br><span class="line"><span class="built_in">exec</span> 格式：</span><br><span class="line">  RUN [<span class="string">"可执行文件"</span>, <span class="string">"参数1"</span>, <span class="string">"参数2"</span>]</span><br><span class="line">  <span class="comment"># 例如：</span></span><br><span class="line">  <span class="comment"># RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline</span></span><br><span class="line">注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</span><br><span class="line">---</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br><span class="line">---</span><br><span class="line">如上，以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[开始构建镜像]</span><br><span class="line">在 Dockerfile 文件的存放目录下，执行构建动作。</span><br><span class="line">以下示例，通过目录下的 Dockerfile 构建一个 nginx:<span class="built_in">test</span>（镜像名称:镜像标签）。</span><br><span class="line">注：最后的 . 代表本次执行的上下文路径，下一节会介绍</span><br><span class="line">$ docker build -t nginx:<span class="built_in">test</span> .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[上下文路径]</span><br><span class="line">上一节中，有提到指令最后一个 . 是上下文路径，那么什么是上下文路径呢？</span><br><span class="line">$ docker build -t nginx:<span class="built_in">test</span> .</span><br><span class="line"></span><br><span class="line">上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</span><br><span class="line"></span><br><span class="line">解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</span><br><span class="line"></span><br><span class="line">如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</span><br><span class="line"></span><br><span class="line">注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[指令详解]</span><br><span class="line"></span><br><span class="line">01	COPY</span><br><span class="line">复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;源路径1&gt;"</span>,...  <span class="string">"&lt;目标路径&gt;"</span>]</span><br><span class="line"></span><br><span class="line">[--chown=&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组。</span><br><span class="line">&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</span><br><span class="line"></span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br><span class="line">&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">02	ADD</span><br><span class="line">ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</span><br><span class="line">  ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</span><br><span class="line">  ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</span><br><span class="line"></span><br><span class="line">03	CMD</span><br><span class="line">类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</span><br><span class="line">  CMD 在docker run 时运行</span><br><span class="line">  RUN 是在 docker build</span><br><span class="line">作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖</span><br><span class="line">注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">"&lt;可执行文件或命令&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...] </span><br><span class="line">CMD [<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br><span class="line"></span><br><span class="line">推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</span><br><span class="line"></span><br><span class="line">04	ENTRYPOINT</span><br><span class="line">类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</span><br><span class="line">但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</span><br><span class="line"></span><br><span class="line">优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</span><br><span class="line">注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">  ENTRYPOINT [<span class="string">"&lt;executeable&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...]</span><br><span class="line">可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">假设已通过 Dockerfile 构建了 nginx:<span class="built_in">test</span> 镜像：</span><br><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"nginx"</span>, <span class="string">"-c"</span>] <span class="comment"># 定参</span></span><br><span class="line">CMD [<span class="string">"/etc/nginx/nginx.conf"</span>] <span class="comment"># 变参</span></span><br><span class="line"></span><br><span class="line">1、不传参运行</span><br><span class="line">$ docker run  nginx:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">容器内会默认运行以下命令，启动主进程</span><br><span class="line">nginx -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">2、传参运行</span><br><span class="line">$ docker run  nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span><br><span class="line"></span><br><span class="line">容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</span><br><span class="line">nginx -c /etc/nginx/new.conf</span><br><span class="line"></span><br><span class="line">05	ENV</span><br><span class="line">设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</span><br><span class="line">格式：</span><br><span class="line">  ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">  ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line">以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 <span class="variable">$NODE_VERSION</span> 引用：</span><br><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span><br><span class="line">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span></span><br><span class="line"></span><br><span class="line">06	ARG</span><br><span class="line">构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，</span><br><span class="line">也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</span><br><span class="line">构建命令 docker build 中可以用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br><span class="line"></span><br><span class="line">07	VOLUME</span><br><span class="line">定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">  避免重要的数据，因容器重启而丢失，这是非常致命的。</span><br><span class="line">  避免容器不断变大</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">  VOLUME [<span class="string">"&lt;路径1&gt;"</span>, <span class="string">"&lt;路径2&gt;"</span>...]</span><br><span class="line">  VOLUME &lt;路径&gt;</span><br><span class="line">  </span><br><span class="line">在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点</span><br><span class="line"></span><br><span class="line">08	EXPOSE</span><br><span class="line">仅仅只是声明端口。</span><br><span class="line">作用：</span><br><span class="line">  帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</span><br><span class="line">  在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</span><br><span class="line">  </span><br><span class="line">格式：</span><br><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br><span class="line"></span><br><span class="line">09	WORKDIR</span><br><span class="line">指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</span><br><span class="line">docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br><span class="line"></span><br><span class="line">10	USER</span><br><span class="line">用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</span><br><span class="line">格式：</span><br><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br><span class="line"></span><br><span class="line">11	HEALTHCHECK</span><br><span class="line">用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br><span class="line"></span><br><span class="line">12	ONBUILD</span><br><span class="line">用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 <span class="built_in">test</span>-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM <span class="built_in">test</span>-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 <span class="built_in">test</span>-build 的 Dockerfile 里的 ONBUILD 指定的命令。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-10-Docker-Compose"><a href="#2-3-10-Docker-Compose" class="headerlink" title="2.3.10 Docker Compose"></a>2.3.10 Docker Compose</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">Compose 简介</span><br><span class="line">Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</span><br><span class="line"></span><br><span class="line">Compose 使用的三个步骤：</span><br><span class="line">  使用 Dockerfile 定义应用程序的环境。</span><br><span class="line">  使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</span><br><span class="line">  最后，执行 docker-compose up 命令来启动并运行整个应用程序。</span><br><span class="line">  </span><br><span class="line">docker-compose.yml 的配置案例如下（配置参数参考下文）：</span><br><span class="line">实例</span><br><span class="line">---</span><br><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">   - <span class="string">"5000:5000"</span></span><br><span class="line">    volumes:</span><br><span class="line">   - .:/code</span><br><span class="line">    - logvolume01:/var/<span class="built_in">log</span></span><br><span class="line">    links:</span><br><span class="line">   - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">[Compose 安装]</span><br><span class="line">Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases</span><br><span class="line">运行以下命令以下载 Docker Compose 的当前稳定版本</span><br><span class="line">$ sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">要安装其他版本的 Compose，请替换 1.24.1</span><br><span class="line">将可执行权限应用于二进制文件：</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">创建软链：</span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">测试是否安装成功：</span><br><span class="line">$ docker-compose --version</span><br><span class="line">cker-compose version 1.24.1, build 4667896b</span><br><span class="line"></span><br><span class="line">注意： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[docker compose 的使用]</span><br><span class="line">1、准备</span><br><span class="line">创建一个测试目录：</span><br><span class="line"></span><br><span class="line">$ mkdir composetest</span><br><span class="line">$ <span class="built_in">cd</span> composetest</span><br><span class="line"></span><br><span class="line">在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：</span><br><span class="line">composetest/app.py 文件代码</span><br><span class="line">---</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=6379)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        try:</span><br><span class="line">            <span class="built_in">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            <span class="keyword">if</span> retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</span><br><span class="line">在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：</span><br><span class="line">flask</span><br><span class="line">redis</span><br><span class="line"></span><br><span class="line">2、创建 Dockerfile 文件</span><br><span class="line">在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：</span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span><br><span class="line"></span><br><span class="line">Dockerfile 内容解释：</span><br><span class="line">  FROM python:3.7-alpine: 从 Python 3.7 映像开始构建镜像。</span><br><span class="line">  WORKDIR /code: 将工作目录设置为 /code。</span><br><span class="line">    ENV FLASK_APP app.py</span><br><span class="line">    ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">    设置 flask 命令使用的环境变量</span><br><span class="line">  RUN apk add --no-cache gcc musl-dev linux-headers: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</span><br><span class="line">    COPY requirements.txt requirements.txt</span><br><span class="line">    RUN pip install -r requirements.txt</span><br><span class="line">    复制 requirements.txt 并安装 Python 依赖项。</span><br><span class="line">  COPY . .: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</span><br><span class="line">  CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]: 容器提供默认的执行命令为：flask run。</span><br><span class="line">  </span><br><span class="line">3、创建 docker-compose.yml</span><br><span class="line">在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</span><br><span class="line"></span><br><span class="line">docker-compose.yml 配置文件</span><br><span class="line">---</span><br><span class="line"><span class="comment"># yaml 配置</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"5000:5000"</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">该 Compose 文件定义了两个服务：web 和 redis</span><br><span class="line">  web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</span><br><span class="line">  redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</span><br><span class="line"></span><br><span class="line">4、使用 Compose 命令构建和运行您的应用</span><br><span class="line">在测试目录中，执行以下命令来启动应用程序：</span><br><span class="line">  docker-compose up</span><br><span class="line">如果你想在后台执行该服务可以加上 -d 参数：</span><br><span class="line">  docker-compose up -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[yml 配置指令参考]</span><br><span class="line"></span><br><span class="line">version</span><br><span class="line">指定本 yml 依从的 compose 哪个版本制定的</span><br><span class="line"></span><br><span class="line">build</span><br><span class="line">指定为构建镜像上下文路径：</span><br><span class="line"></span><br><span class="line">例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</span><br><span class="line">---</span><br><span class="line">version: <span class="string">"3.7"</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line">---</span><br><span class="line">或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</span><br><span class="line">---</span><br><span class="line">version: <span class="string">"3.7"</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - <span class="string">"com.example.description=Accounting webapp"</span></span><br><span class="line">        - <span class="string">"com.example.department=Finance"</span></span><br><span class="line">        - <span class="string">"com.example.label-with-empty-value"</span></span><br><span class="line">      target: prod</span><br><span class="line">---</span><br><span class="line">context：上下文路径。</span><br><span class="line">dockerfile：指定构建镜像的 Dockerfile 文件名。</span><br><span class="line">args：添加构建参数，这是只能在构建过程中访问的环境变量。</span><br><span class="line">labels：设置构建镜像的标签。</span><br><span class="line">target：多层构建，可以指定构建哪一层。</span><br><span class="line"></span><br><span class="line">cap_add，cap_drop</span><br><span class="line">添加或删除容器拥有的宿主机的内核功能。</span><br><span class="line">---</span><br><span class="line">cap_add:</span><br><span class="line">  - ALL <span class="comment"># 开启全部权限</span></span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE <span class="comment"># 关闭 ptrace权限</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">cgroup_parent</span><br><span class="line">为容器指定父 cgroup 组，意味着将继承该组的资源限制。</span><br><span class="line">  cgroup_parent: m-executor-abcd</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">覆盖容器启动的默认命令</span><br><span class="line">  <span class="built_in">command</span>: [<span class="string">"bundle"</span>, <span class="string">"exec"</span>, <span class="string">"thin"</span>, <span class="string">"-p"</span>, <span class="string">"3000"</span>]</span><br><span class="line">  </span><br><span class="line">container_name</span><br><span class="line">指定自定义容器名称，而不是生成的默认名称。</span><br><span class="line">  container_name: my-web-container</span><br><span class="line">  </span><br><span class="line">depends_on</span><br><span class="line">设置依赖关系</span><br><span class="line">  docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</span><br><span class="line">  docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</span><br><span class="line">  docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</span><br><span class="line">---</span><br><span class="line">version: <span class="string">"3.7"</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">---</span><br><span class="line">注意：web 服务不会等待 redis db 完全启动 之后才启动。</span><br><span class="line"></span><br><span class="line">deploy</span><br><span class="line">指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">version: <span class="string">"3.7"</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: <span class="string">"This redis service label"</span></span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">'0.50'</span></span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: <span class="string">'0.25'</span></span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">可以选参数：</span><br><span class="line">endpoint_mode：访问集群服务的方式。</span><br><span class="line">---</span><br><span class="line">endpoint_mode: vip </span><br><span class="line"><span class="comment"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span></span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"><span class="comment"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</span><br><span class="line">mode：指定服务提供的模式。</span><br><span class="line">  replicated：复制服务，复制指定服务到集群的机器上。</span><br><span class="line">  global：全局服务，服务将部署至集群的每个节点。</span><br><span class="line">  图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</span><br></pre></td></tr></table></figure></div>
<p><img src="docker-composex.png" alt="img"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</span><br><span class="line">resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</span><br><span class="line">restart_policy：配置如何在退出容器时重新启动容器。</span><br><span class="line">  condition：可选 none，on-failure 或者 any（默认值：any）。</span><br><span class="line">  delay：设置多久之后重启（默认值：0）。</span><br><span class="line">  max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</span><br><span class="line">  window：设置容器重启超时时间（默认值：0）。</span><br><span class="line">  </span><br><span class="line">rollback_config：配置在更新失败的情况下应如何回滚服务。</span><br><span class="line">  parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</span><br><span class="line">  delay：每个容器组回滚之间等待的时间（默认为0s）。</span><br><span class="line">  failure_action：如果回滚失败，该怎么办。其中一个 <span class="built_in">continue</span> 或者 pause（默认pause）。</span><br><span class="line">  monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</span><br><span class="line">  max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</span><br><span class="line">  order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</span><br><span class="line"></span><br><span class="line">update_config：配置应如何更新服务，对于配置滚动更新很有用。</span><br><span class="line">  parallelism：一次更新的容器数。</span><br><span class="line">  delay：在更新一组容器之间等待的时间。</span><br><span class="line">  failure_action：如果更新失败，该怎么办。其中一个 <span class="built_in">continue</span>，rollback 或者pause （默认：pause）。</span><br><span class="line">  monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</span><br><span class="line">  max_failure_ratio：在更新过程中可以容忍的故障率。</span><br><span class="line">  order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</span><br><span class="line">  </span><br><span class="line">注：仅支持 V3.4 及更高版本。</span><br><span class="line"></span><br><span class="line">devices</span><br><span class="line">指定设备映射列表。</span><br><span class="line">devices:</span><br><span class="line">---</span><br><span class="line">  - <span class="string">"/dev/ttyUSB0:/dev/ttyUSB0"</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">dns</span><br><span class="line">自定义 DNS 服务器，可以是单个值或列表的多个值。</span><br><span class="line">---</span><br><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">dns_search</span><br><span class="line">自定义 DNS 搜索域。可以是单个值或列表。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">entrypoint</span><br><span class="line">覆盖容器默认的 entrypoint。</span><br><span class="line">  entrypoint: /code/entrypoint.sh</span><br><span class="line"></span><br><span class="line">也可以是以下格式：</span><br><span class="line">---</span><br><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/<span class="built_in">local</span>/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">env_file</span><br><span class="line">从文件添加环境变量。可以是单个值或列表的多个值。</span><br><span class="line">---</span><br><span class="line">env_file: .env</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">也可以是列表格式：</span><br><span class="line">---</span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">environment</span><br><span class="line">添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</span><br><span class="line">---</span><br><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: <span class="string">'true'</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">expose</span><br><span class="line">暴露端口，但不映射到宿主机，只被连接的服务访问。</span><br><span class="line">仅可以指定内部端口为参数：</span><br><span class="line">---</span><br><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">extra_hosts</span><br><span class="line">添加主机名映射。类似 docker client --add-host。</span><br><span class="line">extra_hosts:</span><br><span class="line"> - <span class="string">"somehost:162.242.195.82"</span></span><br><span class="line"> - <span class="string">"otherhost:50.31.209.229"</span></span><br><span class="line"> </span><br><span class="line">以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</span><br><span class="line"></span><br><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">healthcheck</span><br><span class="line">用于检测 docker 服务是否健康运行。</span><br><span class="line"></span><br><span class="line">healthcheck:</span><br><span class="line">  <span class="built_in">test</span>: [<span class="string">"CMD"</span>, <span class="string">"curl"</span>, <span class="string">"-f"</span>, <span class="string">"http://localhost"</span>] <span class="comment"># 设置检测程序</span></span><br><span class="line">  interval: 1m30s <span class="comment"># 设置检测间隔</span></span><br><span class="line">  timeout: 10s <span class="comment"># 设置检测超时时间</span></span><br><span class="line">  retries: 3 <span class="comment"># 设置重试次数</span></span><br><span class="line">  start_period: 40s <span class="comment"># 启动后，多少秒开始启动检测程序</span></span><br><span class="line">  </span><br><span class="line">image</span><br><span class="line">指定容器运行的镜像。以下格式都可以：</span><br><span class="line"></span><br><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd <span class="comment"># 镜像id</span></span><br><span class="line"></span><br><span class="line">logging</span><br><span class="line">服务的日志记录配置。</span><br><span class="line">driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</span><br><span class="line"></span><br><span class="line">driver: <span class="string">"json-file"</span></span><br><span class="line">driver: <span class="string">"syslog"</span></span><br><span class="line">driver: <span class="string">"none"</span></span><br><span class="line"></span><br><span class="line">仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: <span class="string">"200k"</span> <span class="comment"># 单个文件大小为200k</span></span><br><span class="line">    max-file: <span class="string">"10"</span> <span class="comment"># 最多10个文件</span></span><br><span class="line">    </span><br><span class="line">当达到文件限制上限，会自动删除旧得文件。</span><br><span class="line">syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: <span class="string">"tcp://192.168.0.42:123"</span></span><br><span class="line">    </span><br><span class="line">network_mode</span><br><span class="line">设置网络模式。</span><br><span class="line"></span><br><span class="line">network_mode: <span class="string">"bridge"</span></span><br><span class="line">network_mode: <span class="string">"host"</span></span><br><span class="line">network_mode: <span class="string">"none"</span></span><br><span class="line">network_mode: <span class="string">"service:[service name]"</span></span><br><span class="line">network_mode: <span class="string">"container:[container name/id]"</span></span><br><span class="line"></span><br><span class="line">networks</span><br><span class="line">配置容器连接的网络，引用顶级 networks 下的条目</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    <span class="comment"># Use a custom driver which takes special options</span></span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    </span><br><span class="line">aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</span><br><span class="line"></span><br><span class="line">restart</span><br><span class="line">  no：是默认的重启策略，在任何情况下都不会重启容器。</span><br><span class="line">  always：容器总是重新启动。</span><br><span class="line">  on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</span><br><span class="line">  unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</span><br><span class="line">  </span><br><span class="line">restart: <span class="string">"no"</span></span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br><span class="line"></span><br><span class="line">注：swarm 集群模式，请改用 restart_policy。</span><br><span class="line"></span><br><span class="line">secrets</span><br><span class="line">存储敏感数据，例如密码：</span><br><span class="line"></span><br><span class="line">version: <span class="string">"3.1"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">    </span><br><span class="line">security_opt</span><br><span class="line">修改容器默认的 schema 标签。</span><br><span class="line"></span><br><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   <span class="comment"># 设置容器的用户标签</span></span><br><span class="line">  - label:role:ROLE   <span class="comment"># 设置容器的角色标签</span></span><br><span class="line">  - label:<span class="built_in">type</span>:TYPE   <span class="comment"># 设置容器的安全策略标签</span></span><br><span class="line">  - label:level:LEVEL  <span class="comment"># 设置容器的安全等级标签</span></span><br><span class="line">  </span><br><span class="line">stop_grace_period</span><br><span class="line">指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器</span><br><span class="line"></span><br><span class="line">stop_grace_period: 1s <span class="comment"># 等待 1 秒</span></span><br><span class="line">stop_grace_period: 1m30s <span class="comment"># 等待 1 分 30 秒 </span></span><br><span class="line"></span><br><span class="line">默认的等待时间是 10 秒。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop_signal</span><br><span class="line">设置停止容器的替代信号。默认情况下使用 SIGTERM 。</span><br><span class="line">以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</span><br><span class="line"></span><br><span class="line">stop_signal: SIGUSR1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sysctls</span><br><span class="line">设置容器中的内核参数，可以使用数组或字典格式。</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br><span class="line">  </span><br><span class="line">tmpfs</span><br><span class="line">在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</span><br><span class="line"></span><br><span class="line">tmpfs: /run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br><span class="line"></span><br><span class="line">ulimits</span><br><span class="line">覆盖容器默认的 <span class="built_in">ulimit</span>。</span><br><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br><span class="line">    </span><br><span class="line">volumes</span><br><span class="line">将主机的数据卷或着文件挂载到容器里。</span><br><span class="line">version: <span class="string">"3.7"</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"/localhost/postgres.sock:/var/run/postgres/postgres.sock"</span></span><br><span class="line">      - <span class="string">"/localhost/data:/var/lib/postgresql/data"</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-11-Docker-Machine"><a href="#2-3-11-Docker-Machine" class="headerlink" title="2.3.11 Docker Machine"></a>2.3.11 Docker Machine</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</span><br><span class="line">Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</span><br><span class="line"></span><br><span class="line">Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</span><br><span class="line">使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</span><br></pre></td></tr></table></figure></div>
<p><img src="machine.png" alt="img"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">[安装]</span><br><span class="line">安装 Docker Machine 之前你需要先安装 Docker。</span><br><span class="line">Docker Mechine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows</span><br><span class="line"></span><br><span class="line">Linux 安装命令</span><br><span class="line">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">  sudo mv /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"></span><br><span class="line">macOS 安装命令</span><br><span class="line">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line">  </span><br><span class="line">Windows 安装命令</span><br><span class="line">如果你是 Windows 平台，可以使用 Git BASH，并输入以下命令：</span><br><span class="line">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  mkdir -p <span class="string">"<span class="variable">$HOME</span>/bin"</span> &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-Windows-x86_64.exe &gt; <span class="string">"<span class="variable">$HOME</span>/bin/docker-machine.exe"</span> &amp;&amp;</span><br><span class="line">  chmod +x <span class="string">"<span class="variable">$HOME</span>/bin/docker-machine.exe"</span></span><br><span class="line">  </span><br><span class="line">查看是否安装成功：</span><br><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[使用]</span><br><span class="line">通过 virtualbox 来介绍 docker-machine 的使用方法。其他云服务商操作与此基本一致。具体可以参考每家服务商的指导文档。</span><br><span class="line">1、列出可用的机器</span><br><span class="line">可以看到目前只有这里默认的 default 虚拟机。</span><br><span class="line"></span><br><span class="line">  $ docker-machine ls</span><br><span class="line">  </span><br><span class="line">2、创建机器</span><br><span class="line">创建一台名为 <span class="built_in">test</span> 的机器。</span><br><span class="line"></span><br><span class="line">  $ docker-machine create --driver virtualbox <span class="built_in">test</span></span><br><span class="line">  </span><br><span class="line">-driver：指定用来创建机器的驱动类型，这里是 virtualbox</span><br><span class="line"></span><br><span class="line">3、查看机器的 ip</span><br><span class="line"></span><br><span class="line">  $ docker-machine ip <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">4、停止机器</span><br><span class="line"></span><br><span class="line">  $ docker-machine stop <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">5、启动机器</span><br><span class="line"></span><br><span class="line">  $ docker-machine start <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">6、进入机器</span><br><span class="line"></span><br><span class="line">  $ docker-machine ssh <span class="built_in">test</span></span><br><span class="line">  </span><br><span class="line">docker-machine 命令参数说明</span><br><span class="line">  docker-machine active：查看当前激活状态的 Docker 主机。</span><br><span class="line">---</span><br><span class="line">$ docker-machine ls</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER         STATE     URL</span><br><span class="line">dev       -        virtualbox     Running   tcp://192.168.99.103:2376</span><br><span class="line">staging   *        digitalocean   Running   tcp://203.0.113.81:2376</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$DOCKER_HOST</span></span><br><span class="line">tcp://203.0.113.81:2376</span><br><span class="line"></span><br><span class="line">$ docker-machine active</span><br><span class="line">staging</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">config：查看当前激活状态 Docker 主机的连接信息。</span><br><span class="line">creat：创建 Docker 主机</span><br><span class="line">env：显示连接到某个主机需要的环境变量</span><br><span class="line">inspect： 以 json 格式输出指定Docker的详细信息</span><br><span class="line">ip： 获取指定 Docker 主机的地址</span><br><span class="line"><span class="built_in">kill</span>： 直接杀死指定的 Docker 主机</span><br><span class="line">ls： 列出所有的管理主机</span><br><span class="line">provision： 重新配置指定主机</span><br><span class="line">regenerate-certs： 为某个主机重新生成 TLS 信息</span><br><span class="line">restart： 重启指定的主机</span><br><span class="line">rm： 删除某台 Docker 主机，对应的虚拟机也会被删除</span><br><span class="line">ssh： 通过 SSH 连接到主机上，执行命令</span><br><span class="line">scp： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据</span><br><span class="line">mount： 使用 SSHFS 从计算机装载或卸载目录</span><br><span class="line">start： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动</span><br><span class="line">status： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</span><br><span class="line">stop： 停止一个指定的 Docker 主机</span><br><span class="line">upgrade： 将一个指定主机的 Docker 版本更新为最新</span><br><span class="line">url： 获取指定 Docker 主机的监听 URL</span><br><span class="line">version： 显示 Docker Machine 的版本或者主机 Docker 版本</span><br><span class="line"><span class="built_in">help</span>： 显示帮助信息</span><br></pre></td></tr></table></figure></div>

<h1 id="三-Docker-常用服务docker化"><a href="#三-Docker-常用服务docker化" class="headerlink" title="三. Docker 常用服务docker化"></a>三. Docker 常用服务docker化</h1><h2 id="3-1-Docker-安装-Ubuntu"><a href="#3-1-Docker-安装-Ubuntu" class="headerlink" title="3.1 Docker 安装 Ubuntu"></a>3.1 Docker 安装 Ubuntu</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">1. 查看可用的 Ubuntu 版本</span><br><span class="line">访问 Ubuntu 镜像库地址： https://hub.docker.com/_/ubuntu?tab=tags&amp;page=1</span><br><span class="line">可以通过 Sort by 查看其他版本的 Ubuntu。默认是最新版本 ubuntu:latest</span><br><span class="line"></span><br><span class="line">2. 拉取最新版的 Ubuntu 镜像</span><br><span class="line">$ docker pull ubuntu</span><br><span class="line">或者：</span><br><span class="line">$ docker pull ubuntu:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器，并且可以通过 <span class="built_in">exec</span> 命令进入 ubuntu 容器</span><br><span class="line">$ docker run -itd --name ubuntu-test ubuntu</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">最后我们可以通过 docker ps 命令查看容器的运行信息</span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-Docker-安装-Centos"><a href="#3-2-Docker-安装-Centos" class="headerlink" title="3.2 Docker 安装 Centos"></a>3.2 Docker 安装 Centos</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">1. 查看可用的 CentOS 版本</span><br><span class="line">访问 CentOS 镜像库地址：https://hub.docker.com/_/centos?tab=tags&amp;page=1。</span><br><span class="line">可以通过 Sort by 查看其他版本的 CentOS 。默认是最新版本 centos:latest</span><br><span class="line"></span><br><span class="line">2. 拉取指定版本的 CentOS 镜像，这里我们安装指定版本为例(centos7):</span><br><span class="line">$ docker pull centos:centos7</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">使用以下命令来查看是否已安装了 centos7：</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器，并且可以通过 <span class="built_in">exec</span> 命令进入 CentOS 容器</span><br><span class="line">$ docker run -itd --name centos-test centos:centos7</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">最后我们可以通过 docker ps 命令查看容器的运行信息</span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-Docker-安装-Nginx"><a href="#3-3-Docker-安装-Nginx" class="headerlink" title="3.3 Docker 安装 Nginx"></a>3.3 Docker 安装 Nginx</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务 </span><br><span class="line"></span><br><span class="line">1. 查看可用的 Nginx 版本</span><br><span class="line">访问 Nginx 镜像库地址： https://hub.docker.com/_/nginx?tab=tags</span><br><span class="line">可以通过 Sort by 查看其他版本的 Nginx，默认是最新版本 nginx:latest</span><br><span class="line"></span><br><span class="line">此外，我们还可以用 docker search nginx 命令来查看可用版本</span><br><span class="line">$ docker search nginx</span><br><span class="line">NAME                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">nginx                     Official build of Nginx.                        3260      [OK]       </span><br><span class="line">jwilder/nginx-proxy       Automated Nginx reverse proxy <span class="keyword">for</span> docker c...   674                  [OK]</span><br><span class="line">richarvey/nginx-php-fpm   Container running Nginx + PHP-FPM capable ...   207                  [OK]</span><br><span class="line">million12/nginx-php       Nginx + PHP-FPM 5.5, 5.6, 7.0 (NG), CentOS...   67                   [OK]</span><br><span class="line">maxexcloo/nginx-php       Docker framework container with Nginx and ...   57                   [OK]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2. 取最新版的 Nginx 镜像</span><br><span class="line">这里我们拉取官方的最新版本的镜像</span><br><span class="line">$ docker pull nginx:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">使用以下命令来查看是否已安装了 nginx：</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器</span><br><span class="line">$ docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">  --name nginx-test：容器名称</span><br><span class="line">  -p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口</span><br><span class="line">  -d nginx： 设置容器在在后台一直运行</span><br><span class="line">  </span><br><span class="line">5. 安装成功</span><br><span class="line">最后可以通过浏览器可以直接访问 8080 端口的 nginx 服务</span><br></pre></td></tr></table></figure></div>

<h2 id="3-4-Docker-安装-Node-js"><a href="#3-4-Docker-安装-Node-js" class="headerlink" title="3.4 Docker 安装 Node.js"></a>3.4 Docker 安装 Node.js</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台</span><br><span class="line"></span><br><span class="line">1. 查看可用的 Node 版本</span><br><span class="line">访问 Node 镜像库地址： https://hub.docker.com/_/node?tab=tags</span><br><span class="line">可以通过 Sort by 查看其他版本的 Node，默认是最新版本 node:latest</span><br><span class="line"></span><br><span class="line">还可以用 docker search node 命令来查看可用版本</span><br><span class="line">$ docker search node</span><br><span class="line"></span><br><span class="line">2. 取最新版的 node 镜像</span><br><span class="line">这里我们拉取官方的最新版本的镜像：</span><br><span class="line">$ docker pull node:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">使用以下命令来查看是否已安装了 node</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器</span><br><span class="line">安装完成后，我们可以使用以下命令来运行 node 容器：</span><br><span class="line">$ docker run -itd --name node-test node</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">--name node-test：容器名称</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">进入查看容器运行的 node 版本</span><br><span class="line">$ docker <span class="built_in">exec</span> -it node-test /bin/bash</span><br><span class="line">root@6c5d265c68a6:/<span class="comment"># node -v</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-5-Docker-安装-PHP"><a href="#3-5-Docker-安装-PHP" class="headerlink" title="3.5 Docker 安装 PHP"></a>3.5 Docker 安装 PHP</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">安装 PHP 镜像</span><br><span class="line"></span><br><span class="line">方法一、docker pull php</span><br><span class="line">查找 Docker Hub 上的 php 镜像:</span><br><span class="line">https://hub.docker.com/_/php?tab=tags</span><br><span class="line"></span><br><span class="line">还可以用 docker search php 命令来查看可用版本</span><br><span class="line">runoob@runoob:~/php-fpm$ docker search php</span><br><span class="line">NAME                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">php                       While designed <span class="keyword">for</span> web development, the PH...   1232      [OK]       </span><br><span class="line">richarvey/nginx-php-fpm   Container running Nginx + PHP-FPM capable ...   207                  [OK]</span><br><span class="line">phpmyadmin/phpmyadmin     A web interface <span class="keyword">for</span> MySQL and MariaDB.          123                  [OK]</span><br><span class="line">eboraas/apache-php        PHP5 on Apache (with SSL support), built o...   69                   [OK]</span><br><span class="line">php-zendserver            Zend Server - the integrated PHP applicati...   69        [OK]       </span><br><span class="line">million12/nginx-php       Nginx + PHP-FPM 5.5, 5.6, 7.0 (NG), CentOS...   67                   [OK]</span><br><span class="line">webdevops/php-nginx       Nginx with PHP-FPM                              39                   [OK]</span><br><span class="line">webdevops/php-apache      Apache with PHP-FPM (based on webdevops/php)    14                   [OK]</span><br><span class="line">phpunit/phpunit           PHPUnit is a programmer-oriented testing f...   14                   [OK]</span><br><span class="line">tetraweb/php              PHP 5.3, 5.4, 5.5, 5.6, 7.0 <span class="keyword">for</span> CI and run...   12                   [OK]</span><br><span class="line">webdevops/php             PHP (FPM and CLI) service container             10                   [OK]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">这里我们拉取官方的镜像,标签为5.6-fpm</span><br><span class="line">runoob@runoob:~/php-fpm$ docker pull php:5.6-fpm</span><br><span class="line"></span><br><span class="line">等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为php,标签为5.6-fpm的镜像</span><br><span class="line">runoob@runoob:~/php-fpm$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">php                 5.6-fpm             025041cd3aa5        6 days ago          456.3 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nginx + PHP 部署</span><br><span class="line"></span><br><span class="line">Nginx 部署可以查看：Docker安装Nginx</span><br><span class="line"></span><br><span class="line">启动 PHP：</span><br><span class="line">$ docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">--name myphp-fpm : 将容器命名为 myphp-fpm</span><br><span class="line">-v ~/nginx/www:/www : 将主机中项目的目录 www 挂载到容器的 /www</span><br><span class="line"></span><br><span class="line">创建 ~/nginx/conf/conf.d 目录：</span><br><span class="line">mkdir ~/nginx/conf/conf.d </span><br><span class="line"></span><br><span class="line">在该目录下添加 ~/nginx/conf/conf.d/runoob-test-php.conf 文件，内容如下：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  /www/<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件说明：</span><br><span class="line">php:9000: 表示 php-fpm 服务的 URL，下面我们会具体说明。</span><br><span class="line">/www/: 是 myphp-fpm 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录</span><br><span class="line"></span><br><span class="line">启动 nginx：</span><br><span class="line">docker run --name runoob-php-nginx -p 8083:80 -d \</span><br><span class="line">&gt; -v ~/nginx/www:/usr/share/nginx/html:ro \</span><br><span class="line">&gt; -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \</span><br><span class="line">&gt; --link myphp-fpm:php \</span><br><span class="line">&gt; nginx</span><br><span class="line"></span><br><span class="line">-p 8083:80: 端口映射，把 nginx 中的 80 映射到本地的 8083 端口。</span><br><span class="line">~/nginx/www: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。</span><br><span class="line">~/nginx/conf/conf.d: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。</span><br><span class="line">--link myphp-fpm:php: 把 myphp-fpm 的网络并入 nginx，并通过修改 nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm</span><br><span class="line"></span><br><span class="line">接下来我们在 ~/nginx/www 目录下创建 index.php，代码如下：</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">浏览器打开 http://127.0.0.1:8083/index.php</span><br></pre></td></tr></table></figure></div>

<h2 id="3-6-Docker-安装-MySQL"><a href="#3-6-Docker-安装-MySQL" class="headerlink" title="3.6 Docker 安装 MySQL"></a>3.6 Docker 安装 MySQL</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">MySQL 是世界上最受欢迎的开源数据库。凭借其可靠性、易用性和性能，MySQL 已成为 Web 应用程序的数据库优先选择</span><br><span class="line"></span><br><span class="line">1. 查看可用的 MySQL 版本</span><br><span class="line">访问 MySQL 镜像库地址：https://hub.docker.com/_/mysql?tab=tags</span><br><span class="line">可以通过 Sort by 查看其他版本的 MySQL，默认是最新版本 mysql:latest </span><br><span class="line"></span><br><span class="line">还可以用 docker search mysql 命令来查看可用版本</span><br><span class="line">$ docker search mysql</span><br><span class="line">NAME                     DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                    MySQL is a widely used, open-source relati...   2529      [OK]       </span><br><span class="line">mysql/mysql-server       Optimized MySQL Server Docker images. Crea...   161                  [OK]</span><br><span class="line">centurylink/mysql        Image containing mysql. Optimized to be li...   45                   [OK]</span><br><span class="line">sameersbn/mysql                                                          36                   [OK]</span><br><span class="line">google/mysql             MySQL server <span class="keyword">for</span> Google Compute Engine          16                   [OK]</span><br><span class="line">appcontainers/mysql      Centos/Debian Based Customizable MySQL Con...   8                    [OK]</span><br><span class="line">marvambass/mysql         MySQL Server based on Ubuntu 14.04              6                    [OK]</span><br><span class="line">drupaldocker/mysql       MySQL <span class="keyword">for</span> Drupal                                2                    [OK]</span><br><span class="line">azukiapp/mysql           Docker image to run MySQL by Azuki - http:...   2                    [OK]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2. 拉取 MySQL 镜像</span><br><span class="line">$ docker pull mysql:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器</span><br><span class="line">$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。</span><br><span class="line">MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">通过 docker ps 命令查看是否安装成功</span><br><span class="line">通过 root 和密码 123456 访问 MySQL 服务</span><br><span class="line"><span class="comment"># mysql -h localhost -u root -p</span></span><br><span class="line"></span><br><span class="line">MySQL(5.7.19)的docker镜像在创建时映射的配置文件目录有所不同</span><br><span class="line">MySQL(5.7.19)的默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。</span><br><span class="line"></span><br><span class="line">具体操作：</span><br><span class="line">首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/opt</span><br><span class="line"><span class="comment"># mkdir -p docker_v/mysql/conf</span></span><br><span class="line"><span class="comment"># cd docker_v/mysql/conf</span></span><br><span class="line"><span class="comment"># touch my.cnf</span></span><br><span class="line"><span class="comment"># docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID</span></span><br><span class="line">4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">-p 3306:3306：将容器的3306端口映射到主机的3306端口</span><br><span class="line">-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码</span><br><span class="line">-d: 后台运行容器，并返回容器ID</span><br><span class="line">imageID: mysql镜像ID</span><br><span class="line"></span><br><span class="line">查看容器运行情况</span><br><span class="line"><span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID IMAGE          COMMAND          ... PORTS                    NAMES</span><br><span class="line">4ec4f56455ea c73c7527c03a  <span class="string">"docker-entrypoint.sh"</span> ... 0.0.0.0:3306-&gt;3306/tcp   mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker 安装 mysql 8 版本</span><br><span class="line"><span class="comment"># docker 中下载 mysql</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'Lzslov123!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加远程登录用户</span></span><br><span class="line">CREATE USER <span class="string">'liaozesong'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'Lzslov123!'</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'liaozesong'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-7-Docker-安装-Tomcat"><a href="#3-7-Docker-安装-Tomcat" class="headerlink" title="3.7 Docker 安装 Tomcat"></a>3.7 Docker 安装 Tomcat</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">方法一、docker pull tomcat</span><br><span class="line">查找 Docker Hub 上的 Tomcat 镜像:</span><br><span class="line">https://hub.docker.com/_/tomcat?tab=tags</span><br><span class="line"></span><br><span class="line">可以用 docker search tomcat 命令来查看可用版本</span><br><span class="line">runoob@runoob:~/tomcat$ docker search tomcat</span><br><span class="line">NAME                       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">tomcat                     Apache Tomcat is an open <span class="built_in">source</span> implementa...   744       [OK]       </span><br><span class="line">dordoka/tomcat             Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 ba...   19                   [OK]</span><br><span class="line">consol/tomcat-7.0          Tomcat 7.0.57, 8080, <span class="string">"admin/admin"</span>              16                   [OK]</span><br><span class="line">consol/tomcat-8.0          Tomcat 8.0.15, 8080, <span class="string">"admin/admin"</span>              14                   [OK]</span><br><span class="line">cloudesire/tomcat          Tomcat server, 6/7/8                            8                    [OK]</span><br><span class="line">davidcaste/alpine-tomcat   Apache Tomcat 7/8 using Oracle Java 7/8 wi...   6                    [OK]</span><br><span class="line">andreptb/tomcat            Debian Jessie based image with Apache Tomc...   4                    [OK]</span><br><span class="line">kieker/tomcat                                                              2                    [OK]</span><br><span class="line">fbrx/tomcat                Minimal Tomcat image based on Alpine Linux      2                    [OK]</span><br><span class="line">jtech/tomcat               Latest Tomcat production distribution on l...   1                    [OK]</span><br><span class="line"></span><br><span class="line">拉取官方的镜像</span><br><span class="line">$ docker pull tomcat</span><br><span class="line"></span><br><span class="line">下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 tomcat 的镜像</span><br><span class="line">$ docker images|grep tomcat</span><br><span class="line">tomcat              latest              70f819d3d2d9        7 days ago          335.8 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二、通过 Dockerfile 构建</span><br><span class="line">创建Dockerfile</span><br><span class="line">首先，创建目录tomcat,用于存放后面的相关东西</span><br><span class="line">$ mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf</span><br><span class="line"></span><br><span class="line">webapps 目录将映射为 tomcat 容器配置的应用程序目录。</span><br><span class="line">logs 目录将映射为 tomcat 容器的日志目录。</span><br><span class="line">conf 目录里的配置文件将映射为 tomcat 容器的配置文件。</span><br><span class="line">进入创建的 tomcat 目录，创建 Dockerfile</span><br><span class="line">FROM openjdk:8-jre</span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/tomcat</span><br><span class="line">ENV PATH <span class="variable">$CATALINA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">RUN mkdir -p <span class="string">"<span class="variable">$CATALINA_HOME</span>"</span></span><br><span class="line">WORKDIR <span class="variable">$CATALINA_HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># let "Tomcat Native" live somewhere isolated</span></span><br><span class="line">ENV TOMCAT_NATIVE_LIBDIR <span class="variable">$CATALINA_HOME</span>/native-jni-lib</span><br><span class="line">ENV LD_LIBRARY_PATH <span class="variable">$&#123;LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:&#125;</span><span class="variable">$TOMCAT_NATIVE_LIBDIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime dependencies for Tomcat Native Libraries</span></span><br><span class="line"><span class="comment"># Tomcat Native 1.2+ requires a newer version of OpenSSL than debian:jessie has available</span></span><br><span class="line"><span class="comment"># &gt; checking OpenSSL library version &gt;= 1.0.2...</span></span><br><span class="line"><span class="comment"># &gt; configure: error: Your version of OpenSSL is not compatible with this version of tcnative</span></span><br><span class="line"><span class="comment"># see http://tomcat.10.x6.nabble.com/VOTE-Release-Apache-Tomcat-8-0-32-tp5046007p5046024.html (and following discussion)</span></span><br><span class="line"><span class="comment"># and https://github.com/docker-library/tomcat/pull/31</span></span><br><span class="line">ENV OPENSSL_VERSION 1.1.0f-3+deb9u2</span><br><span class="line">RUN <span class="built_in">set</span> -ex; \</span><br><span class="line">    currentVersion=<span class="string">"<span class="variable">$(dpkg-query --show --showformat '$&#123;Version&#125;\n' openssl)</span>"</span>; \</span><br><span class="line">    <span class="keyword">if</span> dpkg --compare-versions <span class="string">"<span class="variable">$currentVersion</span>"</span> <span class="string">'&lt;&lt;'</span> <span class="string">"<span class="variable">$OPENSSL_VERSION</span>"</span>; <span class="keyword">then</span> \</span><br><span class="line">        <span class="keyword">if</span> ! grep -q stretch /etc/apt/sources.list; <span class="keyword">then</span> \</span><br><span class="line"><span class="comment"># only add stretch if we're not already building from within stretch</span></span><br><span class="line">            &#123; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'deb http://deb.debian.org/debian stretch main'</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'deb http://security.debian.org stretch/updates main'</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'deb http://deb.debian.org/debian stretch-updates main'</span>; \</span><br><span class="line">            &#125; &gt; /etc/apt/sources.list.d/stretch.list; \</span><br><span class="line">            &#123; \</span><br><span class="line"><span class="comment"># add a negative "Pin-Priority" so that we never ever get packages from stretch unless we explicitly request them</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'Package: *'</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'Pin: release n=stretch*'</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'Pin-Priority: -10'</span>; \</span><br><span class="line">                <span class="built_in">echo</span>; \</span><br><span class="line"><span class="comment"># ... except OpenSSL, which is the reason we're here</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'Package: openssl libssl*'</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Pin: version <span class="variable">$OPENSSL_VERSION</span>"</span>; \</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'Pin-Priority: 990'</span>; \</span><br><span class="line">            &#125; &gt; /etc/apt/preferences.d/stretch-openssl; \</span><br><span class="line">        <span class="keyword">fi</span>; \</span><br><span class="line">        apt-get update; \</span><br><span class="line">        apt-get install -y --no-install-recommends openssl=<span class="string">"<span class="variable">$OPENSSL_VERSION</span>"</span>; \</span><br><span class="line">        rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span><br><span class="line">        libapr1 \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># see https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/KEYS</span></span><br><span class="line"><span class="comment"># see also "update.sh" (https://github.com/docker-library/tomcat/blob/master/update.sh)</span></span><br><span class="line">ENV GPG_KEYS 05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 713DA88BE50911535FE716F5208B0AB1D63011C7 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23</span><br><span class="line"></span><br><span class="line">ENV TOMCAT_MAJOR 8</span><br><span class="line">ENV TOMCAT_VERSION 8.5.32</span><br><span class="line">ENV TOMCAT_SHA512 fc010f4643cb9996cad3812594190564d0a30be717f659110211414faf8063c61fad1f18134154084ad3ddfbbbdb352fa6686a28fbb6402d3207d4e0a88fa9ce</span><br><span class="line"></span><br><span class="line">ENV TOMCAT_TGZ_URLS \</span><br><span class="line"><span class="comment"># https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394</span></span><br><span class="line">    https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz \</span><br><span class="line"><span class="comment"># if the version is outdated, we might have to pull from the dist/archive :/</span></span><br><span class="line">    https://www-us.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz \</span><br><span class="line">    https://www.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz \</span><br><span class="line">    https://archive.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz</span><br><span class="line"></span><br><span class="line">ENV TOMCAT_ASC_URLS \</span><br><span class="line">    https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz.asc \</span><br><span class="line"><span class="comment"># not all the mirrors actually carry the .asc files :'(</span></span><br><span class="line">    https://www-us.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz.asc \</span><br><span class="line">    https://www.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz.asc \</span><br><span class="line">    https://archive.apache.org/dist/tomcat/tomcat-<span class="variable">$TOMCAT_MAJOR</span>/v<span class="variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="variable">$TOMCAT_VERSION</span>.tar.gz.asc</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -eux; \</span><br><span class="line">    \</span><br><span class="line">    savedAptMark=<span class="string">"<span class="variable">$(apt-mark showmanual)</span>"</span>; \</span><br><span class="line">    apt-get update; \</span><br><span class="line">    \</span><br><span class="line">    apt-get install -y --no-install-recommends gnupg dirmngr; \</span><br><span class="line">    \</span><br><span class="line">    <span class="built_in">export</span> GNUPGHOME=<span class="string">"<span class="variable">$(mktemp -d)</span>"</span>; \</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$GPG_KEYS</span>; <span class="keyword">do</span> \</span><br><span class="line">        gpg --keyserver ha.pool.sks-keyservers.net --recv-keys <span class="string">"<span class="variable">$key</span>"</span>; \</span><br><span class="line">    <span class="keyword">done</span>; \</span><br><span class="line">    \</span><br><span class="line">    apt-get install -y --no-install-recommends wget ca-certificates; \</span><br><span class="line">    \</span><br><span class="line">    success=; \</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="variable">$TOMCAT_TGZ_URLS</span>; <span class="keyword">do</span> \</span><br><span class="line">        <span class="keyword">if</span> wget -O tomcat.tar.gz <span class="string">"<span class="variable">$url</span>"</span>; <span class="keyword">then</span> \</span><br><span class="line">            success=1; \</span><br><span class="line">            <span class="built_in">break</span>; \</span><br><span class="line">        <span class="keyword">fi</span>; \</span><br><span class="line">    <span class="keyword">done</span>; \</span><br><span class="line">    [ -n <span class="string">"<span class="variable">$success</span>"</span> ]; \</span><br><span class="line">    \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$TOMCAT_SHA512</span> *tomcat.tar.gz"</span> | sha512sum -c -; \</span><br><span class="line">    \</span><br><span class="line">    success=; \</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="variable">$TOMCAT_ASC_URLS</span>; <span class="keyword">do</span> \</span><br><span class="line">        <span class="keyword">if</span> wget -O tomcat.tar.gz.asc <span class="string">"<span class="variable">$url</span>"</span>; <span class="keyword">then</span> \</span><br><span class="line">            success=1; \</span><br><span class="line">            <span class="built_in">break</span>; \</span><br><span class="line">        <span class="keyword">fi</span>; \</span><br><span class="line">    <span class="keyword">done</span>; \</span><br><span class="line">    [ -n <span class="string">"<span class="variable">$success</span>"</span> ]; \</span><br><span class="line">    \</span><br><span class="line">    gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz; \</span><br><span class="line">    tar -xvf tomcat.tar.gz --strip-components=1; \</span><br><span class="line">    rm bin/*.bat; \</span><br><span class="line">    rm tomcat.tar.gz*; \</span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$GNUPGHOME</span>"</span>; \</span><br><span class="line">    \</span><br><span class="line">    nativeBuildDir=<span class="string">"<span class="variable">$(mktemp -d)</span>"</span>; \</span><br><span class="line">    tar -xvf bin/tomcat-native.tar.gz -C <span class="string">"<span class="variable">$nativeBuildDir</span>"</span> --strip-components=1; \</span><br><span class="line">    apt-get install -y --no-install-recommends \</span><br><span class="line">        dpkg-dev \</span><br><span class="line">        gcc \</span><br><span class="line">        libapr1-dev \</span><br><span class="line">        libssl-dev \</span><br><span class="line">        make \</span><br><span class="line">        <span class="string">"openjdk-<span class="variable">$&#123;JAVA_VERSION%%[.~bu-]*&#125;</span>-jdk=<span class="variable">$JAVA_DEBIAN_VERSION</span>"</span> \</span><br><span class="line">    ; \</span><br><span class="line">    ( \</span><br><span class="line">        <span class="built_in">export</span> CATALINA_HOME=<span class="string">"<span class="variable">$PWD</span>"</span>; \</span><br><span class="line">        <span class="built_in">cd</span> <span class="string">"<span class="variable">$nativeBuildDir</span>/native"</span>; \</span><br><span class="line">        gnuArch=<span class="string">"<span class="variable">$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)</span>"</span>; \</span><br><span class="line">        ./configure \</span><br><span class="line">            --build=<span class="string">"<span class="variable">$gnuArch</span>"</span> \</span><br><span class="line">            --libdir=<span class="string">"<span class="variable">$TOMCAT_NATIVE_LIBDIR</span>"</span> \</span><br><span class="line">            --prefix=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">            --with-apr=<span class="string">"<span class="variable">$(which apr-1-config)</span>"</span> \</span><br><span class="line">            --with-java-home=<span class="string">"<span class="variable">$(docker-java-home)</span>"</span> \</span><br><span class="line">            --with-ssl=yes; \</span><br><span class="line">        make -j <span class="string">"<span class="variable">$(nproc)</span>"</span>; \</span><br><span class="line">        make install; \</span><br><span class="line">    ); \</span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$nativeBuildDir</span>"</span>; \</span><br><span class="line">    rm bin/tomcat-native.tar.gz; \</span><br><span class="line">    \</span><br><span class="line"><span class="comment"># reset apt-mark's "manual" list so that "purge --auto-remove" will remove all build dependencies</span></span><br><span class="line">    apt-mark auto <span class="string">'.*'</span> &gt; /dev/null; \</span><br><span class="line">    [ -z <span class="string">"<span class="variable">$savedAptMark</span>"</span> ] || apt-mark manual <span class="variable">$savedAptMark</span>; \</span><br><span class="line">    apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=<span class="literal">false</span>; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">    \</span><br><span class="line"><span class="comment"># sh removes env vars it doesn't support (ones with periods)</span></span><br><span class="line"><span class="comment"># https://github.com/docker-library/tomcat/issues/77</span></span><br><span class="line">    find ./bin/ -name <span class="string">'*.sh'</span> -<span class="built_in">exec</span> sed -ri <span class="string">'s|^#!/bin/sh$|#!/usr/bin/env bash|'</span> <span class="string">'&#123;&#125;'</span> +</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify Tomcat Native is working properly</span></span><br><span class="line">RUN <span class="built_in">set</span> -e \</span><br><span class="line">    &amp;&amp; nativeLines=<span class="string">"<span class="variable">$(catalina.sh configtest 2&gt;&amp;1)</span>"</span> \</span><br><span class="line">    &amp;&amp; nativeLines=<span class="string">"<span class="variable">$(echo "$nativeLines" | grep 'Apache Tomcat Native')</span>"</span> \</span><br><span class="line">    &amp;&amp; nativeLines=<span class="string">"<span class="variable">$(echo "$nativeLines" | sort -u)</span>"</span> \</span><br><span class="line">    &amp;&amp; <span class="keyword">if</span> ! <span class="built_in">echo</span> <span class="string">"<span class="variable">$nativeLines</span>"</span> | grep <span class="string">'INFO: Loaded APR based Apache Tomcat Native library'</span> &gt;&amp;2; <span class="keyword">then</span> \</span><br><span class="line">        <span class="built_in">echo</span> &gt;&amp;2 <span class="string">"<span class="variable">$nativeLines</span>"</span>; \</span><br><span class="line">        <span class="built_in">exit</span> 1; \</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">"catalina.sh"</span>, <span class="string">"run"</span>]</span><br><span class="line"></span><br><span class="line">通过 Dockerfile 创建一个镜像，替换成你自己的名字</span><br><span class="line">$ docker build -t tomcat .</span><br><span class="line"></span><br><span class="line">创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像</span><br><span class="line">$ docker images|grep tomcat</span><br><span class="line">tomcat              latest              70f819d3d2d9        7 days ago          335.8 MB</span><br><span class="line"></span><br><span class="line">使用 tomcat 镜像</span><br><span class="line">运行容器</span><br><span class="line">$ docker run --name tomcat -p 8080:8080 -v <span class="variable">$PWD</span>/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span> -d tomcat  </span><br><span class="line">acb33fcb4beb8d7f1ebace6f50f5fc204b1dbe9d524881267aa715c61cf75320</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">-p 8080:8080：将容器的 8080 端口映射到主机的 8080 端口</span><br><span class="line">-v <span class="variable">$PWD</span>/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span>：将主机中当前目录下的 <span class="built_in">test</span> 挂载到容器的 /<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">查看容器启动情况</span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND               ... PORTS                    NAMES</span><br><span class="line">acb33fcb4beb    tomcat    <span class="string">"catalina.sh run"</span>     ... 0.0.0.0:8080-&gt;8080/tcp   tomcat</span><br><span class="line"></span><br><span class="line">通过浏览器访问</span><br><span class="line">http://xx.xx.xx.xx:8080</span><br></pre></td></tr></table></figure></div>

<h2 id="3-8-Docker-安装-Python"><a href="#3-8-Docker-安装-Python" class="headerlink" title="3.8 Docker 安装 Python"></a>3.8 Docker 安装 Python</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">方法一、docker pull python:3.5</span><br><span class="line">查找 Docker Hub 上的 Python 镜像:</span><br><span class="line">https://hub.docker.com/_/python?tab=tags</span><br><span class="line"></span><br><span class="line">可以用 docker search python 命令来查看可用版本：</span><br><span class="line">$ docker search python</span><br><span class="line">NAME                           DESCRIPTION                        STARS     OFFICIAL   AUTOMATED</span><br><span class="line">python                         Python is an interpreted,...       982       [OK]       </span><br><span class="line">kaggle/python                  Docker image <span class="keyword">for</span> Python...         33                   [OK]</span><br><span class="line">azukiapp/python                Docker image to run Python ...     3                    [OK]</span><br><span class="line">vimagick/python                mini python                                  2          [OK]</span><br><span class="line">tsuru/python                   Image <span class="keyword">for</span> the Python ...           2                    [OK]</span><br><span class="line">pandada8/alpine-python         An alpine based python image                 1          [OK]</span><br><span class="line">1science/python                Python Docker images based on ...  1                    [OK]</span><br><span class="line">lucidfrontier45/python-uwsgi   Python with uWSGI                  1                    [OK]</span><br><span class="line">orbweb/python                  Python image                       1                    [OK]</span><br><span class="line">pathwar/python                 Python template <span class="keyword">for</span> Pathwar levels 1                    [OK]</span><br><span class="line">rounds/10m-python              Python, setuptools and pip.        0                    [OK]</span><br><span class="line">ruimashita/python              ubuntu 14.04 python                0                    [OK]</span><br><span class="line">tnanba/python                  Python on CentOS-7 image.          0                    [OK]</span><br><span class="line"></span><br><span class="line">拉取官方的镜像,标签为3.5</span><br><span class="line">$ docker pull python:3.5</span><br><span class="line"></span><br><span class="line">下载完成后，在本地镜像列表里查到 REPOSITORY 为python, 标签为 3.5 的镜像</span><br><span class="line">$ docker images python:3.5 </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">python              3.5              045767ddf24a        9 days ago          684.1 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二、通过 Dockerfile 构建</span><br><span class="line">创建 Dockerfile</span><br><span class="line">首先，创建目录 python，用于存放后面的相关东西</span><br><span class="line"></span><br><span class="line">$ mkdir -p ~/python ~/python/myapp</span><br><span class="line"></span><br><span class="line">myapp 目录将映射为 python 容器配置的应用目录</span><br><span class="line">进入创建的 python 目录，创建 Dockerfile</span><br><span class="line"></span><br><span class="line">FROM buildpack-deps:jessie</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove several traces of debian python</span></span><br><span class="line">RUN apt-get purge -y python.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># http://bugs.python.org/issue19846</span></span><br><span class="line"><span class="comment"># &gt; At the moment, setting "LANG=C" on a Linux system *fundamentally breaks Python 3*, and that's not OK.</span></span><br><span class="line">ENV LANG C.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># gpg: key F73C700D: public key "Larry Hastings &lt;larry@hastings.org&gt;" imported</span></span><br><span class="line">ENV GPG_KEY 97FC712E4C024BBEA48A61ED3A5CA953F73C700D</span><br><span class="line"></span><br><span class="line">ENV PYTHON_VERSION 3.5.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># if this is called "PIP_VERSION", pip explodes with "ValueError: invalid truth value '&lt;VERSION&gt;'"</span></span><br><span class="line">ENV PYTHON_PIP_VERSION 8.1.2</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -ex \</span><br><span class="line">        &amp;&amp; curl -fSL <span class="string">"https://www.python.org/ftp/python/<span class="variable">$&#123;PYTHON_VERSION%%[a-z]*&#125;</span>/Python-<span class="variable">$PYTHON_VERSION</span>.tar.xz"</span> -o python.tar.xz \</span><br><span class="line">        &amp;&amp; curl -fSL <span class="string">"https://www.python.org/ftp/python/<span class="variable">$&#123;PYTHON_VERSION%%[a-z]*&#125;</span>/Python-<span class="variable">$PYTHON_VERSION</span>.tar.xz.asc"</span> -o python.tar.xz.asc \</span><br><span class="line">        &amp;&amp; <span class="built_in">export</span> GNUPGHOME=<span class="string">"<span class="variable">$(mktemp -d)</span>"</span> \</span><br><span class="line">        &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys <span class="string">"<span class="variable">$GPG_KEY</span>"</span> \</span><br><span class="line">        &amp;&amp; gpg --batch --verify python.tar.xz.asc python.tar.xz \</span><br><span class="line">        &amp;&amp; rm -r <span class="string">"<span class="variable">$GNUPGHOME</span>"</span> python.tar.xz.asc \</span><br><span class="line">        &amp;&amp; mkdir -p /usr/src/python \</span><br><span class="line">        &amp;&amp; tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \</span><br><span class="line">        &amp;&amp; rm python.tar.xz \</span><br><span class="line">        \</span><br><span class="line">        &amp;&amp; <span class="built_in">cd</span> /usr/src/python \</span><br><span class="line">        &amp;&amp; ./configure --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-unicode=ucs4 \</span><br><span class="line">        &amp;&amp; make -j$(nproc) \</span><br><span class="line">        &amp;&amp; make install \</span><br><span class="line">        &amp;&amp; ldconfig \</span><br><span class="line">        &amp;&amp; pip3 install --no-cache-dir --upgrade --ignore-installed pip==<span class="variable">$PYTHON_PIP_VERSION</span> \</span><br><span class="line">        &amp;&amp; find /usr/<span class="built_in">local</span> -depth \</span><br><span class="line">                \( \</span><br><span class="line">                    \( -<span class="built_in">type</span> d -a -name <span class="built_in">test</span> -o -name tests \) \</span><br><span class="line">                    -o \</span><br><span class="line">                    \( -<span class="built_in">type</span> f -a -name <span class="string">'*.pyc'</span> -o -name <span class="string">'*.pyo'</span> \) \</span><br><span class="line">                \) -<span class="built_in">exec</span> rm -rf <span class="string">'&#123;&#125;'</span> + \</span><br><span class="line">        &amp;&amp; rm -rf /usr/src/python ~/.cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># make some useful symlinks that are expected to exist</span></span><br><span class="line">RUN <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin \</span><br><span class="line">        &amp;&amp; ln -s easy_install-3.5 easy_install \</span><br><span class="line">        &amp;&amp; ln -s idle3 idle \</span><br><span class="line">        &amp;&amp; ln -s pydoc3 pydoc \</span><br><span class="line">        &amp;&amp; ln -s python3 python \</span><br><span class="line">        &amp;&amp; ln -s python3-config python-config</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"python3"</span>]</span><br><span class="line"></span><br><span class="line">通过 Dockerfile 创建一个镜像，替换成你自己的名字</span><br><span class="line">$ docker build -t python:3.5 .</span><br><span class="line"></span><br><span class="line">创建完成后，在本地的镜像列表里查找到刚刚创建的镜像：</span><br><span class="line">runoob@runoob:~/python$ docker images python:3.5 </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">python              3.5              045767ddf24a        9 days ago          684.1 MB</span><br><span class="line"></span><br><span class="line">使用 python 镜像</span><br><span class="line">在 ~/python/myapp 目录下创建一个 helloworld.py 文件，代码如下：</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line"></span><br><span class="line">运行容器</span><br><span class="line">runoob@runoob:~/python$ docker run  -v <span class="variable">$PWD</span>/myapp:/usr/src/myapp  -w /usr/src/myapp python:3.5 python helloworld.py</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">-v <span class="variable">$PWD</span>/myapp:/usr/src/myapp: 将主机中当前目录下的 myapp 挂载到容器的 /usr/src/myapp</span><br><span class="line">-w /usr/src/myapp: 指定容器的 /usr/src/myapp 目录为工作目录</span><br><span class="line">python helloworld.py: 使用容器的 python 命令来执行工作目录中的 helloworld.py 文件</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></div>

<h2 id="3-9-Docker-安装-Redis"><a href="#3-9-Docker-安装-Redis" class="headerlink" title="3.9 Docker 安装 Redis"></a>3.9 Docker 安装 Redis</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 的 NoSQL 数据库，并提供多种语言的 API</span><br><span class="line"></span><br><span class="line">1. 查看可用的 Redis 版本</span><br><span class="line">访问 Redis 镜像库地址： https://hub.docker.com/_/redis?tab=tags</span><br><span class="line">可以通过 Sort by 查看其他版本的 Redis，默认是最新版本 redis:latest</span><br><span class="line"></span><br><span class="line">可以用 docker search redis 命令来查看可用版本</span><br><span class="line">$ docker search  redis</span><br><span class="line">NAME                      DESCRIPTION                   STARS  OFFICIAL  AUTOMATED</span><br><span class="line">redis                     Redis is an open <span class="built_in">source</span> ...   2321   [OK]       </span><br><span class="line">sameersbn/redis                                         32                   [OK]</span><br><span class="line">torusware/speedus-redis   Always updated official ...   29             [OK]</span><br><span class="line">bitnami/redis             Bitnami Redis Docker Image    22                   [OK]</span><br><span class="line">anapsix/redis             11MB Redis server image ...   6                    [OK]</span><br><span class="line">webhippie/redis           Docker images <span class="keyword">for</span> redis       4                    [OK]</span><br><span class="line">clue/redis-benchmark      A minimal docker image t...   3                    [OK]</span><br><span class="line">williamyeh/redis          Redis image <span class="keyword">for</span> Docker        3                    [OK]</span><br><span class="line">unblibraries/redis        Leverages phusion/baseim...   2                    [OK]</span><br><span class="line">greytip/redis             redis 3.0.3                   1                    [OK]</span><br><span class="line">servivum/redis            Redis Docker Image            1                    [OK]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2. 取最新版的 Redis 镜像</span><br><span class="line">拉取官方的最新版本的镜像：</span><br><span class="line">$ docker pull redis:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">使用以下命令来查看是否已下载了 redis：</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器</span><br><span class="line">$ docker run -itd --name redis-test -p 6379:6379 redis</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">可以通过 docker ps 命令查看容器的运行信息</span><br><span class="line">通过 redis-cli 连接测试使用 redis 服务</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it redis-test /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1：6379&gt; <span class="built_in">set</span> <span class="built_in">test</span> 1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></div>

<h2 id="3-10-Docker-安装-MongoDB"><a href="#3-10-Docker-安装-MongoDB" class="headerlink" title="3.10 Docker 安装 MongoDB"></a>3.10 Docker 安装 MongoDB</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">MongoDB 是一个免费的开源跨平台面向文档的 NoSQL 数据库程序</span><br><span class="line"></span><br><span class="line">1. 查看可用的 MongoDB 版本</span><br><span class="line">访问 MongoDB 镜像库地址： https://hub.docker.com/_/mongo?tab=tags&amp;page=1</span><br><span class="line">可以通过 Sort by 查看其他版本的 MongoDB，默认是最新版本 mongo:latest</span><br><span class="line"></span><br><span class="line">还可以用 docker search mongo 命令来查看可用版本</span><br><span class="line">$ docker search mongo</span><br><span class="line">NAME                              DESCRIPTION                      STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mongo                             MongoDB document databases ...   1989      [OK]       </span><br><span class="line">mongo-express                     Web-based MongoDB admin int...   22        [OK]       </span><br><span class="line">mvertes/alpine-mongo              light MongoDB container          19                   [OK]</span><br><span class="line">mongooseim/mongooseim-docker      MongooseIM server the lates...   9                    [OK]</span><br><span class="line">torusware/speedus-mongo           Always updated official Mon...   9                    [OK]</span><br><span class="line">jacksoncage/mongo                 Instant MongoDB sharded cluster  6                    [OK]</span><br><span class="line">mongoclient/mongoclient           Official docker image <span class="keyword">for</span> M...   4                    [OK]</span><br><span class="line">jadsonlourenco/mongo-rocks        Percona Mongodb with Rocksd...   4                    [OK]</span><br><span class="line">asteris/apache-php-mongo          Apache2.4 + PHP + Mongo + m...   2                    [OK]</span><br><span class="line">19hz/mongo-container              Mongodb replicaset <span class="keyword">for</span> coreos    1                    [OK]</span><br><span class="line">nitra/mongo                       Mongo3 centos7                   1                    [OK]</span><br><span class="line">ackee/mongo                       MongoDB with fixed Bluemix p...  1                    [OK]</span><br><span class="line">kobotoolbox/mongo                 https://github.com/kobotoolb...  1                    [OK]</span><br><span class="line">valtlfelipe/mongo                 Docker Image based on the la...  1                    [OK]</span><br><span class="line"></span><br><span class="line">2. 取最新版的 MongoDB 镜像</span><br><span class="line">$ docker pull mongo:latest</span><br><span class="line"></span><br><span class="line">3. 查看本地镜像</span><br><span class="line">使用以下命令来查看是否已安装了 mongo</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">4. 运行容器</span><br><span class="line">安装完成后，我们可以使用以下命令来运行 mongo 容器</span><br><span class="line">$ docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-p 27017:27017 ：映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。</span><br><span class="line">--auth：需要密码才能访问容器服务</span><br><span class="line"></span><br><span class="line">5. 安装成功</span><br><span class="line">通过 docker ps 命令查看容器的运行信息</span><br><span class="line"></span><br><span class="line">使用以下命令添加用户和设置密码，并且尝试连接</span><br><span class="line">$ docker <span class="built_in">exec</span> -it mongo mongo admin</span><br><span class="line"><span class="comment"># 创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line">&gt;  db.createUser(&#123; user:<span class="string">'admin'</span>,<span class="built_in">pwd</span>:<span class="string">'123456'</span>,roles:[ &#123; role:<span class="string">'userAdminAnyDatabase'</span>, db: <span class="string">'admin'</span>&#125;]&#125;);</span><br><span class="line"><span class="comment"># 尝试使用上面创建的用户信息进行连接。</span></span><br><span class="line">&gt; db.auth(<span class="string">'admin'</span>, <span class="string">'123456'</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="3-11-Docker-安装-Apache"><a href="#3-11-Docker-安装-Apache" class="headerlink" title="3.11 Docker 安装 Apache"></a>3.11 Docker 安装 Apache</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="code"><pre><span class="line">方法一、docker pull httpd</span><br><span class="line">查找 Docker Hub 上的 httpd 镜像:</span><br><span class="line">https://hub.docker.com/_/httpd?tab=tags</span><br><span class="line"></span><br><span class="line">可以用 docker search httpd 命令来查看可用版本</span><br><span class="line">runoob@runoob:~/apache$ docker search httpd</span><br><span class="line">NAME                           DESCRIPTION                  STARS  OFFICIAL AUTOMATED</span><br><span class="line">httpd                          The Apache HTTP Server ..    524     [OK]       </span><br><span class="line">centos/httpd                                                7                [OK]</span><br><span class="line">rgielen/httpd-image-php5       Docker image <span class="keyword">for</span> Apache...   1                [OK]</span><br><span class="line">microwebapps/httpd-frontend    Httpd frontend allowing...   1                [OK]</span><br><span class="line">lolhens/httpd                  Apache httpd 2 Server        1                [OK]</span><br><span class="line">publici/httpd                  httpd:latest                 0                [OK]</span><br><span class="line">publicisworldwide/httpd        The Apache httpd webser...   0                [OK]</span><br><span class="line">rgielen/httpd-image-simple     Docker image <span class="keyword">for</span> simple...   0                [OK]</span><br><span class="line">solsson/httpd                  Derivatives of the offi...   0                [OK]</span><br><span class="line">rgielen/httpd-image-drush      Apache HTTPD + Drupal S...   0                [OK]</span><br><span class="line">learninglayers/httpd                                        0                [OK]</span><br><span class="line">sohrabkhan/httpd               Docker httpd + php5.6 (...   0                [OK]</span><br><span class="line">aintohvri/docker-httpd         Apache HTTPD Docker ext...   0                [OK]</span><br><span class="line">alizarion/httpd                httpd on centos with mo...   0                [OK]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">拉取官方的镜像</span><br><span class="line">runoob@runoob:~/apache$ docker pull httpd</span><br><span class="line"></span><br><span class="line">可以在本地镜像列表里查到REPOSITORY为httpd的镜像</span><br><span class="line">runoob@runoob:~/apache$ docker images httpd</span><br><span class="line">REPOSITORY     TAG        IMAGE ID        CREATED           SIZE</span><br><span class="line">httpd          latest     da1536b4ef14    23 seconds ago    195.1 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二、通过 Dockerfile 构建</span><br><span class="line"></span><br><span class="line">创建 Dockerfile</span><br><span class="line">首先，创建目录apache,用于存放后面的相关东西。</span><br><span class="line">runoob@runoob:~$ mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </span><br><span class="line"></span><br><span class="line">www 目录将映射为 apache 容器配置的应用程序目录。</span><br><span class="line">logs 目录将映射为 apache 容器的日志目录。</span><br><span class="line">conf 目录里的配置文件将映射为 apache 容器的配置文件。</span><br><span class="line">进入创建的 apache 目录，创建 Dockerfile。</span><br><span class="line"></span><br><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="comment"># add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added</span></span><br><span class="line"><span class="comment">#RUN groupadd -r www-data &amp;&amp; useradd -r --create-home -g www-data www-data</span></span><br><span class="line"></span><br><span class="line">ENV HTTPD_PREFIX /usr/<span class="built_in">local</span>/apache2</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$HTTPD_PREFIX</span>/bin</span><br><span class="line">RUN mkdir -p <span class="string">"<span class="variable">$HTTPD_PREFIX</span>"</span> \</span><br><span class="line">    &amp;&amp; chown www-data:www-data <span class="string">"<span class="variable">$HTTPD_PREFIX</span>"</span></span><br><span class="line">WORKDIR <span class="variable">$HTTPD_PREFIX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install httpd runtime dependencies</span></span><br><span class="line"><span class="comment"># https://httpd.apache.org/docs/2.4/install.html#requirements</span></span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y --no-install-recommends \</span><br><span class="line">        libapr1 \</span><br><span class="line">        libaprutil1 \</span><br><span class="line">        libaprutil1-ldap \</span><br><span class="line">        libapr1-dev \</span><br><span class="line">        libaprutil1-dev \</span><br><span class="line">        libpcre++0 \</span><br><span class="line">        libssl1.0.0 \</span><br><span class="line">    &amp;&amp; rm -r /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ENV HTTPD_VERSION 2.4.20</span><br><span class="line">ENV HTTPD_BZ2_URL https://www.apache.org/dist/httpd/httpd-<span class="variable">$HTTPD_VERSION</span>.tar.bz2</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">' \</span></span><br><span class="line"><span class="string">        ca-certificates \</span></span><br><span class="line"><span class="string">        curl \</span></span><br><span class="line"><span class="string">        bzip2 \</span></span><br><span class="line"><span class="string">        gcc \</span></span><br><span class="line"><span class="string">        libpcre++-dev \</span></span><br><span class="line"><span class="string">        libssl-dev \</span></span><br><span class="line"><span class="string">        make \</span></span><br><span class="line"><span class="string">    '</span> \</span><br><span class="line">    <span class="built_in">set</span> -x \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y --no-install-recommends <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; rm -r /var/lib/apt/lists/* \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; curl -fSL <span class="string">"<span class="variable">$HTTPD_BZ2_URL</span>"</span> -o httpd.tar.bz2 \</span><br><span class="line">    &amp;&amp; curl -fSL <span class="string">"<span class="variable">$HTTPD_BZ2_URL</span>.asc"</span> -o httpd.tar.bz2.asc \</span><br><span class="line"><span class="comment"># see https://httpd.apache.org/download.cgi#verify</span></span><br><span class="line">    &amp;&amp; <span class="built_in">export</span> GNUPGHOME=<span class="string">"<span class="variable">$(mktemp -d)</span>"</span> \</span><br><span class="line">    &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys A93D62ECC3C8EA12DB220EC934EA76E6791485A8 \</span><br><span class="line">    &amp;&amp; gpg --batch --verify httpd.tar.bz2.asc httpd.tar.bz2 \</span><br><span class="line">    &amp;&amp; rm -r <span class="string">"<span class="variable">$GNUPGHOME</span>"</span> httpd.tar.bz2.asc \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; mkdir -p src \</span><br><span class="line">    &amp;&amp; tar -xvf httpd.tar.bz2 -C src --strip-components=1 \</span><br><span class="line">    &amp;&amp; rm httpd.tar.bz2 \</span><br><span class="line">    &amp;&amp; <span class="built_in">cd</span> src \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; ./configure \</span><br><span class="line">        --prefix=<span class="string">"<span class="variable">$HTTPD_PREFIX</span>"</span> \</span><br><span class="line">        --<span class="built_in">enable</span>-mods-shared=reallyall \</span><br><span class="line">    &amp;&amp; make -j<span class="string">"<span class="variable">$(nproc)</span>"</span> \</span><br><span class="line">    &amp;&amp; make install \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; <span class="built_in">cd</span> .. \</span><br><span class="line">    &amp;&amp; rm -r src \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; sed -ri \</span><br><span class="line">        -e <span class="string">'s!^(\s*CustomLog)\s+\S+!\1 /proc/self/fd/1!g'</span> \</span><br><span class="line">        -e <span class="string">'s!^(\s*ErrorLog)\s+\S+!\1 /proc/self/fd/2!g'</span> \</span><br><span class="line">        <span class="string">"<span class="variable">$HTTPD_PREFIX</span>/conf/httpd.conf"</span> \</span><br><span class="line">    \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br><span class="line"></span><br><span class="line">COPY httpd-foreground /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">"httpd-foreground"</span>]</span><br><span class="line"></span><br><span class="line">Dockerfile文件中 COPY httpd-foreground /usr/<span class="built_in">local</span>/bin/ 是将当前目录下的httpd-foreground拷贝到镜像里，作为httpd服务的启动脚本，所以要在本地创建一个脚本文件httpd-foreground</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="comment"># Apache gets grumpy about PID files pre-existing</span></span><br><span class="line">rm -f /usr/<span class="built_in">local</span>/apache2/logs/httpd.pid</span><br><span class="line"><span class="built_in">exec</span> httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">赋予 httpd-foreground 文件可执行权限</span><br><span class="line">runoob@runoob:~/apache$ chmod +x httpd-foreground</span><br><span class="line"></span><br><span class="line">通过 Dockerfile 创建一个镜像，替换成你自己的名字。</span><br><span class="line">runoob@runoob:~/apache$ docker build -t httpd .</span><br><span class="line"></span><br><span class="line">创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像</span><br><span class="line">runoob@runoob:~/apache$ docker images httpd</span><br><span class="line">REPOSITORY     TAG        IMAGE ID        CREATED           SIZE</span><br><span class="line">httpd          latest     da1536b4ef14    23 seconds ago    195.1 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 apache 镜像</span><br><span class="line">运行容器</span><br><span class="line"></span><br><span class="line">docker run -p 80:80 -v <span class="variable">$PWD</span>/www/:/usr/<span class="built_in">local</span>/apache2/htdocs/ -v <span class="variable">$PWD</span>/conf/httpd.conf:/usr/<span class="built_in">local</span>/apache2/conf/httpd.conf -v <span class="variable">$PWD</span>/logs/:/usr/<span class="built_in">local</span>/apache2/logs/ -d httpd</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">-p 80:80: 将容器的 80 端口映射到主机的 80 端口。</span><br><span class="line">-v <span class="variable">$PWD</span>/www/:/usr/<span class="built_in">local</span>/apache2/htdocs/: 将主机中当前目录下的 www 目录挂载到容器的 /usr/<span class="built_in">local</span>/apache2/htdocs/。</span><br><span class="line">-v <span class="variable">$PWD</span>/conf/httpd.conf:/usr/<span class="built_in">local</span>/apache2/conf/httpd.conf: 将主机中当前目录下的 conf/httpd.conf 文件挂载到容器的 /usr/<span class="built_in">local</span>/apache2/conf/httpd.conf。</span><br><span class="line">-v <span class="variable">$PWD</span>/logs/:/usr/<span class="built_in">local</span>/apache2/logs/: 将主机中当前目录下的 logs 目录挂载到容器的 /usr/<span class="built_in">local</span>/apache2/logs/</span><br><span class="line"></span><br><span class="line">查看容器启动情况</span><br><span class="line">runoob@runoob:~/apache$ docker ps</span><br><span class="line">CONTAINER ID  IMAGE   COMMAND             ... PORTS               NAMES</span><br><span class="line">79a97f2aac37  httpd   <span class="string">"httpd-foreground"</span>  ... 0.0.0.0:80-&gt;80/tcp  sharp_swanson</span><br><span class="line"></span><br><span class="line">通过浏览器访问</span><br></pre></td></tr></table></figure></div>




]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/frank-wong.github.io/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/frank-wong.github.io/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
